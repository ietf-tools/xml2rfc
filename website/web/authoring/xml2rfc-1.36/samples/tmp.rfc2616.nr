.\" automatically generated by xml2rfc v1.36 on 2011-03-26T15:47:09Z
.\" 
.pl 10.0i
.po 0
.ll 7.2i
.lt 7.2i
.nr LL 7.2i
.nr LT 7.2i
.ds LF Fielding, et al.
.ds RF FORMFEED[Page %]
.ds CF Standards Track
.ds LH RFC\02616
.ds RH June 1999
.ds CH HTTP/1.1
.hy 0
.nh
.ad l
.nf
.in 0
Network Working Group                                        R. Fielding
Request for Comments: 2616                                     UC Irvine
Obsoletes: 2068                                                J. Gettys
Category: Standards Track                                     Compaq/W3C
                                                                J. Mogul
                                                                  Compaq
                                                              H. Frystyk
                                                                 W3C/MIT
                                                             L. Masinter
                                                                   Xerox
                                                                P. Leach
                                                               Microsoft
                                                          T. \%Berners-Lee
                                                                 W3C/MIT
                                                               June 1999


.ce
Hypertext Transfer Protocol \%-- HTTP/1.1

.in 3
.ti 0
Status of this Memo

.fi
This document specifies an Internet standards track protocol for the
Internet community, and requests discussion and suggestions for
improvements.  Please refer to the current edition of the "Internet
Official Protocol Standards" (STD\01) for the standardization state
and status of this protocol.  Distribution of this memo is unlimited.

.ti 0
Copyright Notice

Copyright (C) The Internet Society (1999).  All Rights Reserved.
.bp
.ti 0
Abstract

The Hypertext Transfer Protocol (HTTP) is an \%application-level
protocol for distributed, collaborative, hypermedia information
systems.  It is a generic, stateless, protocol which can be used for
many tasks beyond its use for hypertext, such as name servers and
distributed object management systems, through extension of its
request methods, error codes and headers [47].  A feature of HTTP is
the typing and negotiation of data representation, allowing systems
to be built independently of the data being transferred.

HTTP has been in use by the \%World-Wide Web global information
initiative since 1990.  This specification defines the protocol
referred to as "HTTP/1.1", and is an update to RFC 2068 [33].


.in 0
Table of Contents

.nf
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   8
     1.1.   Purpose  . . . . . . . . . . . . . . . . . . . . . . . .   8
     1.2.   Requirements . . . . . . . . . . . . . . . . . . . . . .   8
     1.3.   Terminology  . . . . . . . . . . . . . . . . . . . . . .   9
     1.4.   Overall Operation  . . . . . . . . . . . . . . . . . . .  13
   2.  Notational Conventions and Generic Grammar  . . . . . . . . .  16
     2.1.   Augmented BNF  . . . . . . . . . . . . . . . . . . . . .  16
     2.2.   Basic Rules  . . . . . . . . . . . . . . . . . . . . . .  18
   3.  Protocol Parameters . . . . . . . . . . . . . . . . . . . . .  20
     3.1.   HTTP Version . . . . . . . . . . . . . . . . . . . . . .  20
     3.2.   Uniform Resource Identifiers . . . . . . . . . . . . . .  21
       3.2.1.   General Syntax . . . . . . . . . . . . . . . . . . .  21
       3.2.2.   http URL . . . . . . . . . . . . . . . . . . . . . .  21
       3.2.3.   URI Comparison . . . . . . . . . . . . . . . . . . .  22
     3.3.   Date/Time Formats  . . . . . . . . . . . . . . . . . . .  22
       3.3.1.   Full Date  . . . . . . . . . . . . . . . . . . . . .  22
       3.3.2.   Delta Seconds  . . . . . . . . . . . . . . . . . . .  24
     3.4.   Character Sets . . . . . . . . . . . . . . . . . . . . .  24
       3.4.1.   Missing Charset  . . . . . . . . . . . . . . . . . .  25
     3.5.   Content Codings  . . . . . . . . . . . . . . . . . . . .  25
     3.6.   Transfer Codings . . . . . . . . . . . . . . . . . . . .  26
       3.6.1.   Chunked Transfer Coding  . . . . . . . . . . . . . .  27
     3.7.   Media Types  . . . . . . . . . . . . . . . . . . . . . .  29
       3.7.1.   Canonicalization and Text Defaults . . . . . . . . .  29
       3.7.2.   Multipart Types  . . . . . . . . . . . . . . . . . .  30
     3.8.   Product Tokens . . . . . . . . . . . . . . . . . . . . .  31
     3.9.   Quality Values . . . . . . . . . . . . . . . . . . . . .  31
     3.10.  Language Tags  . . . . . . . . . . . . . . . . . . . . .  32
     3.11.  Entity Tags  . . . . . . . . . . . . . . . . . . . . . .  32
     3.12.  Range Units  . . . . . . . . . . . . . . . . . . . . . .  33
.bp
   4.  HTTP Message  . . . . . . . . . . . . . . . . . . . . . . . .  34
     4.1.   Message Types  . . . . . . . . . . . . . . . . . . . . .  34
     4.2.   Message Headers  . . . . . . . . . . . . . . . . . . . .  34
     4.3.   Message Body . . . . . . . . . . . . . . . . . . . . . .  35
     4.4.   Message Length . . . . . . . . . . . . . . . . . . . . .  36
     4.5.   General Header Fields  . . . . . . . . . . . . . . . . .  37
   5.  Request . . . . . . . . . . . . . . . . . . . . . . . . . . .  39
     5.1.   \%Request-Line . . . . . . . . . . . . . . . . . . . . . .  39
       5.1.1.   Method . . . . . . . . . . . . . . . . . . . . . . .  39
       5.1.2.   \%Request-URI  . . . . . . . . . . . . . . . . . . . .  40
     5.2.   The Resource Identified by a Request . . . . . . . . . .  41
     5.3.   Request Header Fields  . . . . . . . . . . . . . . . . .  42
   6.  Response  . . . . . . . . . . . . . . . . . . . . . . . . . .  43
     6.1.   \%Status-Line  . . . . . . . . . . . . . . . . . . . . . .  43
       6.1.1.   Status Code and Reason Phrase  . . . . . . . . . . .  43
     6.2.   Response Header Fields . . . . . . . . . . . . . . . . .  46
   7.  Entity  . . . . . . . . . . . . . . . . . . . . . . . . . . .  47
     7.1.   Entity Header Fields . . . . . . . . . . . . . . . . . .  47
     7.2.   Entity Body  . . . . . . . . . . . . . . . . . . . . . .  47
       7.2.1.   Type . . . . . . . . . . . . . . . . . . . . . . . .  48
       7.2.2.   Entity Length  . . . . . . . . . . . . . . . . . . .  48
   8.  Connections . . . . . . . . . . . . . . . . . . . . . . . . .  49
     8.1.   Persistent Connections . . . . . . . . . . . . . . . . .  49
       8.1.1.   Purpose  . . . . . . . . . . . . . . . . . . . . . .  49
       8.1.2.   Overall Operation  . . . . . . . . . . . . . . . . .  49
       8.1.3.   Proxy Servers  . . . . . . . . . . . . . . . . . . .  51
       8.1.4.   Practical Considerations . . . . . . . . . . . . . .  51
     8.2.   Message Transmission Requirements  . . . . . . . . . . .  52
       8.2.1.   Persistent Connections and Flow Control  . . . . . .  52
       8.2.2.   Monitoring Connections for Error Status Messages . .  52
       8.2.3.   Use of the 100 (Continue) Status . . . . . . . . . .  53
       8.2.4.   Client Behavior if Server Prematurely Closes
                Connection . . . . . . . . . . . . . . . . . . . . .  55
   9.  Method Definitions  . . . . . . . . . . . . . . . . . . . . .  56
     9.1.   Safe and Idempotent Methods  . . . . . . . . . . . . . .  56
       9.1.1.   Safe Methods . . . . . . . . . . . . . . . . . . . .  56
       9.1.2.   Idempotent Methods . . . . . . . . . . . . . . . . .  56
     9.2.   OPTIONS  . . . . . . . . . . . . . . . . . . . . . . . .  57
     9.3.   GET  . . . . . . . . . . . . . . . . . . . . . . . . . .  58
     9.4.   HEAD . . . . . . . . . . . . . . . . . . . . . . . . . .  58
     9.5.   POST . . . . . . . . . . . . . . . . . . . . . . . . . .  59
     9.6.   PUT  . . . . . . . . . . . . . . . . . . . . . . . . . .  60
     9.7.   DELETE . . . . . . . . . . . . . . . . . . . . . . . . .  61
     9.8.   TRACE  . . . . . . . . . . . . . . . . . . . . . . . . .  61
     9.9.   CONNECT  . . . . . . . . . . . . . . . . . . . . . . . .  62
   10. Status Code Definitions . . . . . . . . . . . . . . . . . . .  63
     10.1.  Informational 1xx  . . . . . . . . . . . . . . . . . . .  63
       10.1.1.  100 Continue . . . . . . . . . . . . . . . . . . . .  63
.bp
       10.1.2.  101 Switching Protocols  . . . . . . . . . . . . . .  63
     10.2.  Successful 2xx . . . . . . . . . . . . . . . . . . . . .  64
       10.2.1.  200 OK . . . . . . . . . . . . . . . . . . . . . . .  64
       10.2.2.  201 Created  . . . . . . . . . . . . . . . . . . . .  64
       10.2.3.  202 Accepted . . . . . . . . . . . . . . . . . . . .  64
       10.2.4.  203 \%Non-Authoritative Information  . . . . . . . . .  65
       10.2.5.  204 No Content . . . . . . . . . . . . . . . . . . .  65
       10.2.6.  205 Reset Content  . . . . . . . . . . . . . . . . .  65
       10.2.7.  206 Partial Content  . . . . . . . . . . . . . . . .  66
     10.3.  Redirection 3xx  . . . . . . . . . . . . . . . . . . . .  66
       10.3.1.  300 Multiple Choices . . . . . . . . . . . . . . . .  67
       10.3.2.  301 Moved Permanently  . . . . . . . . . . . . . . .  67
       10.3.3.  302 Found  . . . . . . . . . . . . . . . . . . . . .  68
       10.3.4.  303 See Other  . . . . . . . . . . . . . . . . . . .  68
       10.3.5.  304 Not Modified . . . . . . . . . . . . . . . . . .  69
       10.3.6.  305 Use Proxy  . . . . . . . . . . . . . . . . . . .  69
       10.3.7.  306 (Unused) . . . . . . . . . . . . . . . . . . . .  70
       10.3.8.  307 Temporary Redirect . . . . . . . . . . . . . . .  70
     10.4.  Client Error 4xx . . . . . . . . . . . . . . . . . . . .  70
       10.4.1.  400 Bad Request  . . . . . . . . . . . . . . . . . .  71
       10.4.2.  401 Unauthorized . . . . . . . . . . . . . . . . . .  71
       10.4.3.  402 Payment Required . . . . . . . . . . . . . . . .  71
       10.4.4.  403 Forbidden  . . . . . . . . . . . . . . . . . . .  71
       10.4.5.  404 Not Found  . . . . . . . . . . . . . . . . . . .  71
       10.4.6.  405 Method Not Allowed . . . . . . . . . . . . . . .  72
       10.4.7.  406 Not Acceptable . . . . . . . . . . . . . . . . .  72
       10.4.8.  407 Proxy Authentication Required  . . . . . . . . .  72
       10.4.9.  408 Request Timeout  . . . . . . . . . . . . . . . .  73
       10.4.10. 409 Conflict . . . . . . . . . . . . . . . . . . . .  73
       10.4.11. 410 Gone . . . . . . . . . . . . . . . . . . . . . .  73
       10.4.12. 411 Length Required  . . . . . . . . . . . . . . . .  74
       10.4.13. 412 Precondition Failed  . . . . . . . . . . . . . .  74
       10.4.14. 413 Request Entity Too Large . . . . . . . . . . . .  74
       10.4.15. 414 \%Request-URI Too Long . . . . . . . . . . . . . .  74
       10.4.16. 415 Unsupported Media Type . . . . . . . . . . . . .  74
       10.4.17. 416 Requested Range Not Satisfiable  . . . . . . . .  74
       10.4.18. 417 Expectation Failed . . . . . . . . . . . . . . .  75
     10.5.  Server Error 5xx . . . . . . . . . . . . . . . . . . . .  75
       10.5.1.  500 Internal Server Error  . . . . . . . . . . . . .  75
       10.5.2.  501 Not Implemented  . . . . . . . . . . . . . . . .  75
       10.5.3.  502 Bad Gateway  . . . . . . . . . . . . . . . . . .  75
       10.5.4.  503 Service Unavailable  . . . . . . . . . . . . . .  76
       10.5.5.  504 Gateway Timeout  . . . . . . . . . . . . . . . .  76
       10.5.6.  505 HTTP Version Not Supported . . . . . . . . . . .  76
   11. Access Authentication . . . . . . . . . . . . . . . . . . . .  77
   12. Content Negotiation . . . . . . . . . . . . . . . . . . . . .  78
     12.1.  \%Server-driven Negotiation  . . . . . . . . . . . . . . .  78
     12.2.  \%Agent-driven Negotiation . . . . . . . . . . . . . . . .  79
.bp
     12.3.  Transparent Negotiation  . . . . . . . . . . . . . . . .  80
   13. Caching in HTTP . . . . . . . . . . . . . . . . . . . . . . .  81
     13.1.   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  82
       13.1.1.  Cache Correctness  . . . . . . . . . . . . . . . . .  82
       13.1.2.  Warnings . . . . . . . . . . . . . . . . . . . . . .  83
       13.1.3.  \%Cache-control Mechanisms . . . . . . . . . . . . . .  84
       13.1.4.  Explicit User Agent Warnings . . . . . . . . . . . .  84
       13.1.5.  Exceptions to the Rules and Warnings . . . . . . . .  85
       13.1.6.  \%Client-controlled Behavior . . . . . . . . . . . . .  85
     13.2.  Expiration Model . . . . . . . . . . . . . . . . . . . .  86
       13.2.1.  \%Server-Specified Expiration  . . . . . . . . . . . .  86
       13.2.2.  Heuristic Expiration . . . . . . . . . . . . . . . .  86
       13.2.3.  Age Calculations . . . . . . . . . . . . . . . . . .  87
       13.2.4.  Expiration Calculations  . . . . . . . . . . . . . .  89
       13.2.5.  Disambiguating Expiration Values . . . . . . . . . .  90
       13.2.6.  Disambiguating Multiple Responses  . . . . . . . . .  91
     13.3.  Validation Model . . . . . . . . . . . . . . . . . . . .  91
       13.3.1.  \%Last-Modified Dates  . . . . . . . . . . . . . . . .  92
       13.3.2.  Entity Tag Cache Validators  . . . . . . . . . . . .  92
       13.3.3.  Weak and Strong Validators . . . . . . . . . . . . .  93
       13.3.4.  Rules for When to Use Entity Tags and
                \%Last-Modified Dates  . . . . . . . . . . . . . . . .  95
       13.3.5.  \%Non-validating Conditionals  . . . . . . . . . . . .  97
     13.4.  Response Cacheability  . . . . . . . . . . . . . . . . .  97
     13.5.  Constructing Responses From Caches . . . . . . . . . . .  98
       13.5.1.  \%End-to-end and \%Hop-by-hop Headers  . . . . . . . . .  98
       13.5.2.  \%Non-modifiable Headers . . . . . . . . . . . . . . .  99
       13.5.3.  Combining Headers  . . . . . . . . . . . . . . . . . 100
       13.5.4.  Combining Byte Ranges  . . . . . . . . . . . . . . . 101
     13.6.  Caching Negotiated Responses . . . . . . . . . . . . . . 102
     13.7.  Shared and \%Non-Shared Caches . . . . . . . . . . . . . . 103
     13.8.  Errors or Incomplete Response Cache Behavior . . . . . . 103
     13.9.  Side Effects of GET and HEAD . . . . . . . . . . . . . . 104
     13.10. Invalidation After Updates or Deletions  . . . . . . . . 104
     13.11. \%Write-Through Mandatory  . . . . . . . . . . . . . . . . 105
     13.12. Cache Replacement  . . . . . . . . . . . . . . . . . . . 105
     13.13. History Lists  . . . . . . . . . . . . . . . . . . . . . 106
   14. Header Field Definitions  . . . . . . . . . . . . . . . . . . 107
     14.1.  Accept . . . . . . . . . . . . . . . . . . . . . . . . . 107
     14.2.  \%Accept-Charset . . . . . . . . . . . . . . . . . . . . . 109
     14.3.  \%Accept-Encoding  . . . . . . . . . . . . . . . . . . . . 109
     14.4.  \%Accept-Language  . . . . . . . . . . . . . . . . . . . . 111
     14.5.  \%Accept-Ranges  . . . . . . . . . . . . . . . . . . . . . 112
     14.6.  Age  . . . . . . . . . . . . . . . . . . . . . . . . . . 112
     14.7.  Allow  . . . . . . . . . . . . . . . . . . . . . . . . . 113
     14.8.  Authorization  . . . . . . . . . . . . . . . . . . . . . 113
     14.9.  \%Cache-Control  . . . . . . . . . . . . . . . . . . . . . 114
       14.9.1.  What is Cacheable  . . . . . . . . . . . . . . . . . 116
.bp
       14.9.2.  What May be Stored by Caches . . . . . . . . . . . . 117
       14.9.3.  Modifications of the Basic Expiration Mechanism  . . 118
       14.9.4.  Cache Revalidation and Reload Controls . . . . . . . 120
       14.9.5.  \%No-Transform Directive . . . . . . . . . . . . . . . 122
       14.9.6.  Cache Control Extensions . . . . . . . . . . . . . . 123
     14.10. Connection . . . . . . . . . . . . . . . . . . . . . . . 124
     14.11. \%Content-Encoding . . . . . . . . . . . . . . . . . . . . 125
     14.12. \%Content-Language . . . . . . . . . . . . . . . . . . . . 125
     14.13. \%Content-Length . . . . . . . . . . . . . . . . . . . . . 126
     14.14. \%Content-Location . . . . . . . . . . . . . . . . . . . . 127
     14.15. \%Content-MD5  . . . . . . . . . . . . . . . . . . . . . . 128
     14.16. \%Content-Range  . . . . . . . . . . . . . . . . . . . . . 129
     14.17. \%Content-Type . . . . . . . . . . . . . . . . . . . . . . 131
     14.18. Date . . . . . . . . . . . . . . . . . . . . . . . . . . 131
       14.18.1. Clockless Origin Server Operation  . . . . . . . . . 132
     14.19. ETag . . . . . . . . . . . . . . . . . . . . . . . . . . 133
     14.20. Expect . . . . . . . . . . . . . . . . . . . . . . . . . 133
     14.21. Expires  . . . . . . . . . . . . . . . . . . . . . . . . 134
     14.22. From . . . . . . . . . . . . . . . . . . . . . . . . . . 135
     14.23. Host . . . . . . . . . . . . . . . . . . . . . . . . . . 135
     14.24. \%If-Match . . . . . . . . . . . . . . . . . . . . . . . . 136
     14.25. \%If-Modified-Since  . . . . . . . . . . . . . . . . . . . 137
     14.26. \%If-None-Match  . . . . . . . . . . . . . . . . . . . . . 139
     14.27. \%If-Range . . . . . . . . . . . . . . . . . . . . . . . . 140
     14.28. \%If-Unmodified-Since  . . . . . . . . . . . . . . . . . . 141
     14.29. \%Last-Modified  . . . . . . . . . . . . . . . . . . . . . 141
     14.30. Location . . . . . . . . . . . . . . . . . . . . . . . . 142
     14.31. \%Max-Forwards . . . . . . . . . . . . . . . . . . . . . . 142
     14.32. Pragma . . . . . . . . . . . . . . . . . . . . . . . . . 143
     14.33. \%Proxy-Authenticate . . . . . . . . . . . . . . . . . . . 144
     14.34. \%Proxy-Authorization  . . . . . . . . . . . . . . . . . . 144
     14.35. Range  . . . . . . . . . . . . . . . . . . . . . . . . . 144
       14.35.1. Byte Ranges  . . . . . . . . . . . . . . . . . . . . 144
       14.35.2. Range Retrieval Requests . . . . . . . . . . . . . . 146
     14.36. Referer  . . . . . . . . . . . . . . . . . . . . . . . . 147
     14.37. \%Retry-After  . . . . . . . . . . . . . . . . . . . . . . 147
     14.38. Server . . . . . . . . . . . . . . . . . . . . . . . . . 148
     14.39. TE . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
     14.40. Trailer  . . . . . . . . . . . . . . . . . . . . . . . . 149
     14.41. \%Transfer-Encoding  . . . . . . . . . . . . . . . . . . . 150
     14.42. Upgrade  . . . . . . . . . . . . . . . . . . . . . . . . 150
     14.43. \%User-Agent . . . . . . . . . . . . . . . . . . . . . . . 152
     14.44. Vary . . . . . . . . . . . . . . . . . . . . . . . . . . 152
     14.45. Via  . . . . . . . . . . . . . . . . . . . . . . . . . . 153
     14.46. Warning  . . . . . . . . . . . . . . . . . . . . . . . . 154
     14.47. \%WWW-Authenticate . . . . . . . . . . . . . . . . . . . . 157
   15. Security Considerations . . . . . . . . . . . . . . . . . . . 158
     15.1.  Personal Information . . . . . . . . . . . . . . . . . . 158
.bp
       15.1.1.  Abuse of Server Log Information  . . . . . . . . . . 158
       15.1.2.  Transfer of Sensitive Information  . . . . . . . . . 158
       15.1.3.  Encoding Sensitive Information in URI\'s  . . . . . . 159
       15.1.4.  Privacy Issues Connected to Accept Headers . . . . . 160
     15.2.  Attacks Based On File and Path Names . . . . . . . . . . 160
     15.3.  DNS Spoofing . . . . . . . . . . . . . . . . . . . . . . 161
     15.4.  Location Headers and Spoofing  . . . . . . . . . . . . . 161
     15.5.  \%Content-Disposition Issues . . . . . . . . . . . . . . . 162
     15.6.  Authentication Credentials and Idle Clients  . . . . . . 162
     15.7.  Proxies and Caching  . . . . . . . . . . . . . . . . . . 162
       15.7.1.  Denial of Service Attacks on Proxies . . . . . . . . 163
   16. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . 164
   17. References  . . . . . . . . . . . . . . . . . . . . . . . . . 166
   Appendix A.  Appendices . . . . . . . . . . . . . . . . . . . . . 170
     A.1.   Internet Media Type message/http and application/http  . 170
     A.2.   Internet Media Type multipart/byteranges . . . . . . . . 171
     A.3.   Tolerant Applications  . . . . . . . . . . . . . . . . . 172
     A.4.   Differences Between HTTP Entities and RFC 2045
            Entities . . . . . . . . . . . . . . . . . . . . . . . . 173
       A.4.1.   \%MIME-Version . . . . . . . . . . . . . . . . . . . . 174
       A.4.2.   Conversion to Canonical Form . . . . . . . . . . . . 174
       A.4.3.   Conversion of Date Formats . . . . . . . . . . . . . 174
       A.4.4.   Introduction of \%Content-Encoding . . . . . . . . . . 175
       A.4.5.   No \%Content-Transfer-Encoding . . . . . . . . . . . . 175
       A.4.6.   Introduction of \%Transfer-Encoding  . . . . . . . . . 175
       A.4.7.   MHTML and Line Length Limitations  . . . . . . . . . 176
     A.5.   Additional Features  . . . . . . . . . . . . . . . . . . 176
       A.5.1.   \%Content-Disposition  . . . . . . . . . . . . . . . . 176
     A.6.   Compatibility with Previous Versions . . . . . . . . . . 177
       A.6.1.   Changes from HTTP/1.0  . . . . . . . . . . . . . . . 178
       A.6.2.   Compatibility with HTTP/1.0 Persistent Connections . 179
       A.6.3.   Changes from RFC 2068  . . . . . . . . . . . . . . . 179
   Appendix B.  Index  . . . . . . . . . . . . . . . . . . . . . . . 183
   Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
   Authors\' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 196
   Intellectual Property and Copyright Statements  . . . . . . . . . 198
.bp
.fi
.in 4
.ti 0
1.  Introduction
.in 3

.in 6
.ti 0
1.1.  Purpose
.in 3

The Hypertext Transfer Protocol (HTTP) is an \%application-level
protocol for distributed, collaborative, hypermedia information
systems.  HTTP has been in use by the \%World-Wide Web global
information initiative since 1990.  The first version of HTTP,
referred to as HTTP/0.9, was a simple protocol for raw data transfer
across the Internet.  HTTP/1.0, as defined by RFC 1945 [6], improved
the protocol by allowing messages to be in the format of \%MIME-like
messages, containing metainformation about the data transferred and
modifiers on the request/response semantics.  However, HTTP/1.0 does
not sufficiently take into consideration the effects of hierarchical
proxies, caching, the need for persistent connections, or virtual
hosts.  In addition, the proliferation of \%incompletely-implemented
applications calling themselves "HTTP/1.0" has necessitated a
protocol version change in order for two communicating applications
to determine each other\'s true capabilities.

This specification defines the protocol referred to as "HTTP/1.1".
This protocol includes more stringent requirements than HTTP/1.0 in
order to ensure reliable implementation of its features.

Practical information systems require more functionality than simple
retrieval, including search, \%front-end update, and annotation.  HTTP
allows an \%open-ended set of methods and headers that indicate the
purpose of a request [47].  It builds on the discipline of reference
provided by the Uniform Resource Identifier (URI) [3], as a location
(URL) [4] or name (URN) [20], for indicating the resource to which a
method is to be applied.  Messages are passed in a format similar to
that used by Internet mail [9] as defined by the Multipurpose
Internet Mail Extensions (MIME) [7].

HTTP is also used as a generic protocol for communication between
user agents and proxies/gateways to other Internet systems, including
those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],
and WAIS [10] protocols.  In this way, HTTP allows basic hypermedia
access to resources available from diverse applications.

.in 6
.ti 0
1.2.  Requirements
.in 3

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 [34].

An implementation is not compliant if it fails to satisfy one or more
of the MUST or REQUIRED level requirements for the protocols it
.bp
implements.  An implementation that satisfies all the MUST or
REQUIRED level and all the SHOULD level requirements for its
protocols is said to be "unconditionally compliant"; one that
satisfies all the MUST level requirements but not all the SHOULD
level requirements for its protocols is said to be "conditionally
compliant."

.in 6
.ti 0
1.3.  Terminology
.in 3

This specification uses a number of terms to refer to the roles
played by participants in, and objects of, the HTTP communication.

connection

.in 6
.ti 6
A transport layer virtual circuit established between two programs
for the purpose of communication.

.in 3
message

.in 6
.ti 6
The basic unit of HTTP communication, consisting of a structured
sequence of octets matching the syntax defined in Section\04 and
transmitted via the connection.

.in 3
request

.in 6
.ti 6
An HTTP request message, as defined in Section\05.

.in 3
response

.in 6
.ti 6
An HTTP response message, as defined in Section\06.

.in 3
resource

.in 6
.ti 6
A network data object or service that can be identified by a URI,
as defined in Section\03.2.  Resources may be available in multiple
representations (e.g. multiple languages, data formats, size, and
resolutions) or vary in other ways.

.in 3
entity

.in 6
.ti 6
The information transferred as the payload of a request or
response.  An entity consists of metainformation in the form of
\%entity-header fields and content in the form of an \%entity-body, as
described in Section\07.

.in 3
.bp
representation

.in 6
.ti 6
An entity included with a response that is subject to content
negotiation, as described in Section\012.  There may exist multiple
representations associated with a particular response status.

.in 3
content negotiation

.in 6
.ti 6
The mechanism for selecting the appropriate representation when
servicing a request, as described in Section\012.  The
representation of entities in any response can be negotiated
(including error responses).

.in 3
variant

.in 6
.ti 6
A resource may have one, or more than one, representation(s)
associated with it at any given instant.  Each of these
representations is termed a `varriant\'.  Use of the term `variant\'
does not necessarily imply that the resource is subject to content
negotiation.

.in 3
client

.in 6
.ti 6
A program that establishes connections for the purpose of sending
requests.

.in 3
user agent

.in 6
.ti 6
The client which initiates a request.  These are often browsers,
editors, spiders \%(web-traversing robots), or other end user tools.

.in 3
server

.in 6
.ti 6
An application program that accepts connections in order to
service requests by sending back responses.  Any given program may
be capable of being both a client and a server; our use of these
terms refers only to the role being performed by the program for a
particular connection, rather than to the program\'s capabilities
in general.  Likewise, any server may act as an origin server,
proxy, gateway, or tunnel, switching behavior based on the nature
of each request.

.in 3
origin server

.in 6
.ti 6
The server on which a given resource resides or is to be created.

.in 3
.bp
proxy

.in 6
.ti 6
An intermediary program which acts as both a server and a client
for the purpose of making requests on behalf of other clients.
Requests are serviced internally or by passing them on, with
possible translation, to other servers.  A proxy MUST implement
both the client and server requirements of this specification.  A
"transparent proxy" is a proxy that does not modify the request or
response beyond what is required for proxy authentication and
identification.  A \%"non-transparent proxy" is a proxy that
modifies the request or response in order to provide some added
service to the user agent, such as group annotation services,
media type transformation, protocol reduction, or anonymity
filtering.  Except where either transparent or \%non-transparent
behavior is explicitly stated, the HTTP proxy requirements apply
to both types of proxies.

.in 3
gateway

.in 6
.ti 6
A server which acts as an intermediary for some other server.
Unlike a proxy, a gateway receives requests as if it were the
origin server for the requested resource; the requesting client
may not be aware that it is communicating with a gateway.

.in 3
tunnel

.in 6
.ti 6
An intermediary program which is acting as a blind relay between
two connections.  Once active, a tunnel is not considered a party
to the HTTP communication, though the tunnel may have been
initiated by an HTTP request.  The tunnel ceases to exist when
both ends of the relayed connections are closed.

.in 3
cache

.in 6
.ti 6
A program\'s local store of response messages and the subsystem
that controls its message storage, retrieval, and deletion.  A
cache stores cacheable responses in order to reduce the response
time and network bandwidth consumption on future, equivalent
requests.  Any client or server may include a cache, though a
cache cannot be used by a server that is acting as a tunnel.

.in 3
cacheable

.in 6
.ti 6
A response is cacheable if a cache is allowed to store a copy of
the response message for use in answering subsequent requests.
The rules for determining the cacheability of HTTP responses are
defined in Section\013.  Even if a resource is cacheable, there may
be additional constraints on whether a cache can use the cached
.bp
copy for a particular request.

.in 3
\%first-hand

.in 6
.ti 6
A response is \%first-hand if it comes directly and without
unnecessary delay from the origin server, perhaps via one or more
proxies.  A response is also \%first-hand if its validity has just
been checked directly with the origin server.

.in 3
explicit expiration time

.in 6
.ti 6
The time at which the origin server intends that an entity should
no longer be returned by a cache without further validation.

.in 3
heuristic expiration time

.in 6
.ti 6
An expiration time assigned by a cache when no explicit expiration
time is available.

.in 3
age

.in 6
.ti 6
The age of a response is the time since it was sent by, or
successfully validated with, the origin server.

.in 3
freshness lifetime

.in 6
.ti 6
The length of time between the generation of a response and its
expiration time.

.in 3
fresh

.in 6
.ti 6
A response is fresh if its age has not yet exceeded its freshness
lifetime.

.in 3
stale

.in 6
.ti 6
A response is stale if its age has passed its freshness lifetime.

.in 3
semantically transparent

.in 6
.ti 6
A cache behaves in a "semantically transparent" manner, with
respect to a particular response, when its use affects neither the
requesting client nor the origin server, except to improve
performance.  When a cache is semantically transparent, the client
receives exactly the same response (except for \%hop-by-hop headers)
that it would have received had its request been handled directly
by the origin server.

.bp
.in 3
validator

.in 6
.ti 6
A protocol element (e.g., an entity tag or a \%Last-Modified time)
that is used to find out whether a cache entry is an equivalent
copy of an entity.

.in 3
upstream/downstream

.in 6
.ti 6
Upstream and downstream describe the flow of a message: all
messages flow from upstream to downstream.

.in 3
inbound/outbound

.in 6
.ti 6
Inbound and outbound refer to the request and response paths for
messages: "inbound" means "traveling toward the origin server",
and "outbound" means "traveling toward the user agent"

.in 3
.in 6
.ti 0
1.4.  Overall Operation
.in 3

The HTTP protocol is a request/response protocol.  A client sends a
request to the server in the form of a request method, URI, and
protocol version, followed by a \%MIME-like message containing request
modifiers, client information, and possible body content over a
connection with a server.  The server responds with a status line,
including the message\'s protocol version and a success or error code,
followed by a \%MIME-like message containing server information, entity
metainformation, and possible \%entity-body content.  The relationship
between HTTP and MIME is described in Appendix\0A.4.

Most HTTP communication is initiated by a user agent and consists of
a request to be applied to a resource on some origin server.  In the
simplest case, this may be accomplished via a single connection (v)
between the user agent (UA) and the origin server (O).
.nf

       request chain ------------------------>
    UA -------------------v------------------- O
       <----------------------- response chain

.fi
A more complicated situation occurs when one or more intermediaries
are present in the request/response chain.  There are three common
forms of intermediary: proxy, gateway, and tunnel.  A proxy is a
forwarding agent, receiving requests for a URI in its absolute form,
rewriting all or part of the message, and forwarding the reformatted
request toward the server identified by the URI.  A gateway is a
receiving agent, acting as a layer above some other server(s) and, if
necessary, translating the requests to the underlying server\'s
protocol.  A tunnel acts as a relay point between two connections
without changing the messages; tunnels are used when the
.bp
communication needs to pass through an intermediary (such as a
firewall) even when the intermediary cannot understand the contents
of the messages.
.nf

       request chain -------------------------------------->
    UA -----v----- A -----v----- B -----v----- C -----v----- O
       <------------------------------------- response chain

.fi
The figure above shows three intermediaries (A, B, and C) between the
user agent and origin server.  A request or response message that
travels the whole chain will pass through four separate connections.
This distinction is important because some HTTP communication options
may apply only to the connection with the nearest, \%non-tunnel
neighbor, only to the \%end-points of the chain, or to all connections
along the chain.  Although the diagram is linear, each participant
may be engaged in multiple, simultaneous communications.  For
example, B may be receiving requests from many clients other than A,
and/or forwarding requests to servers other than C, at the same time
that it is handling A\'s request.

Any party to the communication which is not acting as a tunnel may
employ an internal cache for handling requests.  The effect of a
cache is that the request/response chain is shortened if one of the
participants along the chain has a cached response applicable to that
request.  The following illustrates the resulting chain if B has a
cached copy of an earlier response from O (via C) for a request which
has not been cached by UA or A.
.nf

          request chain ---------->
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          <--------- response chain

.fi
Not all responses are usefully cacheable, and some requests may
contain modifiers which place special requirements on cache behavior.
HTTP requirements for cache behavior and cacheable responses are
defined in Section\013.

In fact, there are a wide variety of architectures and configurations
of caches and proxies currently being experimented with or deployed
across the World Wide Web. These systems include national hierarchies
of proxy caches to save transoceanic bandwidth, systems that
broadcast or multicast cache entries, organizations that distribute
subsets of cached data via \%CD-ROM, and so on.  HTTP systems are used
in corporate intranets over \%high-bandwidth links, and for access via
PDAs with \%low-power radio links and intermittent connectivity.  The
goal of HTTP/1.1 is to support the wide diversity of configurations
already deployed while introducing protocol constructs that meet the
needs of those who build web applications that require high
.bp
reliability and, failing that, at least reliable indications of
failure.

HTTP communication usually takes place over TCP/IP connections.  The
default port is TCP 80 [19], but other ports can be used.  This does
not preclude HTTP from being implemented on top of any other protocol
on the Internet, or on other networks.  HTTP only presumes a reliable
transport; any protocol that provides such guarantees can be used;
the mapping of the HTTP/1.1 request and response structures onto the
transport data units of the protocol in question is outside the scope
of this specification.

In HTTP/1.0, most implementations used a new connection for each
request/response exchange.  In HTTP/1.1, a connection may be used for
one or more request/response exchanges, although connections may be
closed for a variety of reasons (see Section\08.1).
.bp
.in 4
.ti 0
2.  Notational Conventions and Generic Grammar
.in 3

.in 6
.ti 0
2.1.  Augmented BNF
.in 3

All of the mechanisms specified in this document are described in
both prose and an augmented \%Backus-Naur Form (BNF) similar to that
used by RFC 822 [9].  Implementors will need to be familiar with the
notation in order to understand this specification.  The augmented
BNF includes the following constructs:

name = definition

.in 6
.ti 6
The name of a rule is simply the name itself (without any
enclosing "<" and ">") and is separated from its definition by the
equal "=" character.  White space is only significant in that
indentation of continuation lines is used to indicate a rule
definition that spans more than one line.  Certain basic rules are
in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc.  Angle
brackets are used within definitions whenever their presence will
facilitate discerning the use of rule names.

.in 3
"literal"

.in 6
.ti 6
Quotation marks surround literal text.  Unless stated otherwise,
the text is \%case-insensitive.

.in 3
rule1 | rule2

.in 6
.ti 6
Elements separated by a bar ("|") are alternatives, e.g., "yes |
no" will accept yes or no.

.in 3
(rule1 rule2)

.in 6
.ti 6
Elements enclosed in parentheses are treated as a single element.
Thus, "(elem (foo | bar) elem)" allows the token sequences "elem
foo elem" and "elem bar elem".

.in 3
*rule

.in 6
.ti 6
The character "*" preceding an element indicates repetition.  The
full form is "<n>*<m>element" indicating at least <n> and at most
<m> occurrences of element.  Default values are 0 and infinity so
that "*(element)" allows any number, including zero; "1*element"
requires at least one; and "1*2element" allows one or two.

.in 3
[rule]
.bp
.in 6
.ti 6
Square brackets enclose optional elements; "[foo bar]" is
equivalent to "*1(foo bar)".

.in 3
N rule

.in 6
.ti 6
Specific repetition: "<n>(element)" is equivalent to
"<n>*<n>(element)"; that is, exactly <n> occurrences of (element).
Thus 2DIGIT is a \%2-digit number, and 3ALPHA is a string of three
alphabetic characters.

.in 3
#rule

.in 6
.ti 6
A construct "#" is defined, similar to "*", for defining lists of
elements.  The full form is "<n>#<m>element" indicating at least
<n> and at most <m> elements, each separated by one or more commas
(",") and OPTIONAL linear white space (LWS).  This makes the usual
form of lists very easy; a rule such as
.nf

.in 3
   ( *LWS element *( *LWS "," *LWS element ))

.fi
.in 6
.ti 6
can be shown as
.nf

.in 3
   1#element

.fi
.in 6
.ti 6
Wherever this construct is used, null elements are allowed, but do
not contribute to the count of elements present.  That is,
"(element), , (element) " is permitted, but counts as only two
elements.  Therefore, where at least one element is required, at
least one \%non-null element MUST be present.  Default values are 0
and infinity so that "#element" allows any number, including zero;
"1#element" requires at least one; and "1#2element" allows one or
two.

.in 3
; comment

.in 6
.ti 6
A \%semi-colon, set off some distance to the right of rule text,
starts a comment that continues to the end of line.  This is a
simple way of including useful notes in parallel with the
specifications.

.in 3
implied *LWS

.in 6
.ti 6
The grammar described by this specification is \%word-based.  Except
where noted otherwise, linear white space (LWS) can be included
between any two adjacent words (token or \%quoted-string), and
between adjacent words and separators, without changing the
interpretation of a field.  At least one delimiter (LWS and/or
separators) MUST exist between any two tokens (for the definition
.bp
of "token" below), since they would otherwise be interpreted as a
single token.

.in 3
.in 6
.ti 0
2.2.  Basic Rules
.in 3

The following rules are used throughout this specification to
describe basic parsing constructs.  The \%US-ASCII coded character set
is defined by ANSI \%X3.4-1986 [21].
.nf

    OCTET          = <any 8-bit sequence of data>
    CHAR           = <any US-ASCII character (octets 0 - 127)>
    UPALPHA        = <any US-ASCII uppercase letter "A".."Z">
    LOALPHA        = <any US-ASCII lowercase letter "a".."z">
    ALPHA          = UPALPHA | LOALPHA
    DIGIT          = <any US-ASCII digit "0".."9">
    CTL            = <any US-ASCII control character
                     (octets 0 - 31) and DEL (127)>
    CR             = <US-ASCII CR, carriage return (13)>
    LF             = <US-ASCII LF, linefeed (10)>
    SP             = <US-ASCII SP, space (32)>
    HT             = <US-ASCII HT, horizontal-tab (9)>
    <">            = <US-ASCII double-quote mark (34)>

.fi
HTTP/1.1 defines the sequence CR LF as the \%end-of-line marker for all
protocol elements except the \%entity-body (see Appendix\0A.3 for
tolerant applications).  The \%end-of-line marker within an \%entity-body
is defined by its associated media type, as described in Section\03.7.
.nf

    CRLF           = CR LF

.fi
HTTP/1.1 header field values can be folded onto multiple lines if the
continuation line begins with a space or horizontal tab.  All linear
white space, including folding, has the same semantics as SP.  A
recipient MAY replace any linear white space with a single SP before
interpreting the field value or forwarding the message downstream.
.nf

    LWS            = [CRLF] 1*( SP | HT )

.fi
The TEXT rule is only used for descriptive field contents and values
that are not intended to be interpreted by the message parser.  Words
of *TEXT MAY contain characters from character sets other than \%ISO-
\%8859-1 [22] only when encoded according to the rules of RFC 2047
[14].
.nf

    TEXT           = <any OCTET except CTLs,
                     but including LWS>

.fi
A CRLF is allowed in the definition of TEXT only as part of a header
.bp
field continuation.  It is expected that the folding LWS will be
replaced with a single SP before interpretation of the TEXT value.

Hexadecimal numeric characters are used in several protocol elements.
.nf

    HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                   | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

.fi
Many HTTP/1.1 header field values consist of words separated by LWS
or special characters.  These special characters MUST be in a quoted
string to be used within a parameter value (as defined in
Section\03.6).
.nf

    token          = 1*<any CHAR except CTLs or separators>
    separators     = "(" | ")" | "<" | ">" | "@"
                   | "," | ";" | ":" | "\\" | <">
                   | "/" | "[" | "]" | "?" | "="
                   | "{" | "}" | SP | HT

.fi
Comments can be included in some HTTP header fields by surrounding
the comment text with parentheses.  Comments are only allowed in
fields containing "comment" as part of their field value definition.
In all other fields, parentheses are considered part of the field
value.
.nf

    comment        = "(" *( ctext | quoted-pair | comment ) ")"
    ctext          = <any TEXT excluding "(" and ")">

.fi
A string of text is parsed as a single word if it is quoted using
\%double-quote marks.
.nf

    quoted-string  = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext         = <any TEXT except <">>

.fi
The backslash character ("\\") MAY be used as a \%single-character
quoting mechanism only within \%quoted-string and comment constructs.
.nf

    quoted-pair    = "\\" CHAR

.bp
.fi
.in 4
.ti 0
3.  Protocol Parameters
.in 3

.in 6
.ti 0
3.1.  HTTP Version
.in 3

HTTP uses a "<major>.<minor>" numbering scheme to indicate versions
of the protocol.  The protocol versioning policy is intended to allow
the sender to indicate the format of a message and its capacity for
understanding further HTTP communication, rather than the features
obtained via that communication.  No change is made to the version
number for the addition of message components which do not affect
communication behavior or which only add to extensible field values.
The <minor> number is incremented when the changes made to the
protocol add features which do not change the general message parsing
algorithm, but which may add to the message semantics and imply
additional capabilities of the sender.  The <major> number is
incremented when the format of a message within the protocol is
changed.  See RFC 2145 [36] for a fuller explanation.

The version of an HTTP message is indicated by an \%HTTP-Version field
in the first line of the message.
.nf

       HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT

.fi
Note that the major and minor numbers MUST be treated as separate
integers and that each MAY be incremented higher than a single digit.
Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
lower than HTTP/12.3.  Leading zeros MUST be ignored by recipients
and MUST NOT be sent.

An application that sends a request or response message that includes
\%HTTP-Version of "HTTP/1.1" MUST be at least conditionally compliant
with this specification.  Applications that are at least
conditionally compliant with this specification SHOULD use an \%HTTP-
Version of "HTTP/1.1" in their messages, and MUST do so for any
message that is not compatible with HTTP/1.0.  For more details on
when to send specific \%HTTP-Version values, see RFC 2145 [36].

The HTTP version of an application is the highest HTTP version for
which the application is at least conditionally compliant.

Proxy and gateway applications need to be careful when forwarding
messages in protocol versions different from that of the application.
Since the protocol version indicates the protocol capability of the
sender, a proxy/gateway MUST NOT send a message with a version
indicator which is greater than its actual version.  If a higher
version request is received, the proxy/gateway MUST either downgrade
the request version, or respond with an error, or switch to tunnel
behavior.
.bp
Due to interoperability problems with HTTP/1.0 proxies discovered
since the publication of RFC 2068 [33], caching proxies MUST,
gateways MAY, and tunnels MUST NOT upgrade the request to the highest
version they support.  The proxy/gateway\'s response to that request
MUST be in the same major version as the request.

.in 6
.ti 6
Note: Converting between versions of HTTP may involve modification
of header fields required or forbidden by the versions involved.

.in 3
.in 6
.ti 0
3.2.  Uniform Resource Identifiers
.in 3

URIs have been known by many names: WWW addresses, Universal Document
Identifiers, Universal Resource Identifiers [3], and finally the
combination of Uniform Resource Locators (URL) [4] and Names (URN)
[20].  As far as HTTP is concerned, Uniform Resource Identifiers are
simply formatted strings which \%identify--via name, location, or any
other \%characteristic--a resource.

.in 8
.ti 0
3.2.1.  General Syntax
.in 3

URIs in HTTP can be represented in absolute form or relative to some
known base URI [11], depending upon the context of their use.  The
two forms are differentiated by the fact that absolute URIs always
begin with a scheme name followed by a colon.  For definitive
information on URL syntax and semantics, see "Uniform Resource
Identifiers (URI): Generic Syntax and Semantics," RFC 2396 [42]
(which replaces RFCs 1738 [4] and RFC 1808 [11]).  This specification
adopts the definitions of \%"URI-reference", "absoluteURI",
"relativeURI", "port", "host","abs_path", "rel_path", and "authority"
from that specification.

The HTTP protocol does not place any a priori limit on the length of
a URI.  Servers MUST be able to handle the URI of any resource they
serve, and SHOULD be able to handle URIs of unbounded length if they
provide \%GET-based forms that could generate such URIs.  A server
SHOULD return 414 \%(Request-URI Too Long) status if a URI is longer
than the server can handle (see Section\010.4.15).

.in 6
.ti 6
Note: Servers ought to be cautious about depending on URI lengths
above 255 bytes, because some older client or proxy
implementations might not properly support these lengths.

.in 3
.in 8
.ti 0
3.2.2.  http URL
.in 3

The "http" scheme is used to locate network resources via the HTTP
protocol.  This section defines the \%scheme-specific syntax and
semantics for http URLs.
.nf

.bp
http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ]]

.fi
If the port is empty or not given, port 80 is assumed.  The semantics
are that the identified resource is located at the server listening
for TCP connections on that port of that host, and the \%Request-URI
for the resource is abs_path (Section\05.1.2).  The use of IP
addresses in URLs SHOULD be avoided whenever possible (see RFC 1900
[24]).  If the abs_path is not present in the URL, it MUST be given
as "/" when used as a \%Request-URI for a resource (Section\05.1.2).  If
a proxy receives a host name which is not a fully qualified domain
name, it MAY add its domain to the host name it received.  If a proxy
receives a fully qualified domain name, the proxy MUST NOT change the
host name.

.in 8
.ti 0
3.2.3.  URI Comparison
.in 3

When comparing two URIs to decide if they match or not, a client
SHOULD use a \%case-sensitive \%octet-by-octet comparison of the entire
URIs, with these exceptions:

.in 6
.ti 3
o  A port that is empty or not given is equivalent to the default
port for that \%URI-reference;

.ti 3
o  Comparisons of host names MUST be \%case-insensitive;

.ti 3
o  Comparisons of scheme names MUST be \%case-insensitive;

.ti 3
o  An empty abs_path is equivalent to an abs_path of "/".

.in 3
Characters other than those in the "reserved" and "unsafe" sets (see
RFC 2396 [42]) are equivalent to their ""%" HEX HEX" encoding.

For example, the following three URIs are equivalent:
.nf

   http://abc.com:80/~smith/home.html
   http://ABC.com/%7Esmith/home.html
   http://ABC.com:/%7esmith/home.html

.fi
.in 6
.ti 0
3.3.  Date/Time Formats
.in 3

.in 8
.ti 0
3.3.1.  Full Date
.in 3

HTTP applications have historically allowed three different formats
for the representation of date/time stamps:
.nf

   Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
   Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
   Sun Nov  6 08:49:37 1994       ; ANSI C\'s asctime() format
.bp
.fi
The first format is preferred as an Internet standard and represents
a \%fixed-length subset of that defined by RFC 1123 [8] (an update to
RFC 822 [9]).  The second format is in common use, but is based on
the obsolete RFC 850 [12] date format and lacks a \%four-digit year.
HTTP/1.1 clients and servers that parse the date value MUST accept
all three formats (for compatibility with HTTP/1.0), though they MUST
only generate the RFC 1123 format for representing \%HTTP-date values
in header fields.  See Appendix\0A.3 for further information.

.in 6
.ti 6
Note: Recipients of date values are encouraged to be robust in
accepting date values that may have been sent by \%non-HTTP
applications, as is sometimes the case when retrieving or posting
messages via proxies/gateways to SMTP or NNTP.

.in 3
All HTTP date/time stamps MUST be represented in Greenwich Mean Time
(GMT), without exception.  For the purposes of HTTP, GMT is exactly
equal to UTC (Coordinated Universal Time).  This is indicated in the
first two formats by the inclusion of "GMT" as the \%three-letter
abbreviation for time zone, and MUST be assumed when reading the
asctime format.  \%HTTP-date is case sensitive and MUST NOT include
additional LWS beyond that specifically included as SP in the
grammar.
.nf

    HTTP-date    = rfc1123-date | rfc850-date | asctime-date
    rfc1123-date = wkday "," SP date1 SP time SP "GMT"
    rfc850-date  = weekday "," SP date2 SP time SP "GMT"
    asctime-date = wkday SP date3 SP time SP 4DIGIT
    date1        = 2DIGIT SP month SP 4DIGIT
                   ; day month year (e.g., 02 Jun 1982)
    date2        = 2DIGIT "-" month "-" 2DIGIT
                   ; day-month-year (e.g., 02-Jun-82)
    date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                   ; month day (e.g., Jun  2)
    time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                   ; 00:00:00 - 23:59:59
    wkday        = "Mon" | "Tue" | "Wed"
                 | "Thu" | "Fri" | "Sat" | "Sun"
    weekday      = "Monday" | "Tuesday" | "Wednesday"
                 | "Thursday" | "Friday" | "Saturday" | "Sunday"
    month        = "Jan" | "Feb" | "Mar" | "Apr"
                 | "May" | "Jun" | "Jul" | "Aug"
                 | "Sep" | "Oct" | "Nov" | "Dec"

.fi
Note: HTTP requirements for the date/time stamp format apply only to
their usage within the protocol stream.  Clients and servers are not
required to use these formats for user presentation, request logging,
etc.
.bp
.in 8
.ti 0
3.3.2.  Delta Seconds
.in 3

Some HTTP header fields allow a time value to be specified as an
integer number of seconds, represented in decimal, after the time
that the message was received.
.nf

    delta-seconds  = 1*DIGIT

.fi
.in 6
.ti 0
3.4.  Character Sets
.in 3

HTTP uses the same definition of the term "character set" as that
described for MIME:

The term "character set" is used in this document to refer to a
method used with one or more tables to convert a sequence of octets
into a sequence of characters.  Note that unconditional conversion in
the other direction is not required, in that not all characters may
be available in a given character set and a character set may provide
more than one sequence of octets to represent a particular character.
This definition is intended to allow various kinds of character
encoding, from simple \%single-table mappings such as \%US-ASCII to
complex table switching methods such as those that use \%ISO-2022\'s
techniques.  However, the definition associated with a MIME character
set name MUST fully specify the mapping to be performed from octets
to characters.  In particular, use of external profiling information
to determine the exact mapping is not permitted.

.in 6
.ti 6
Note: This use of the term "character set" is more commonly
referred to as a "character encoding."  However, since HTTP and
MIME share the same registry, it is important that the terminology
also be shared.

.in 3
HTTP character sets are identified by \%case-insensitive tokens.  The
complete set of tokens is defined by the IANA Character Set registry
[19].
.nf

    charset = token

.fi
Although HTTP allows an arbitrary token to be used as a charset
value, any token that has a predefined value within the IANA
Character Set registry [19] MUST represent the character set defined
by that registry.  Applications SHOULD limit their use of character
sets to those defined by the IANA registry.

Implementors should be aware of IETF character set requirements [38]
[41].
.bp
.in 8
.ti 0
3.4.1.  Missing Charset
.in 3

Some HTTP/1.0 software has interpreted a \%Content-Type header without
charset parameter incorrectly to mean "recipient should guess."
Senders wishing to defeat this behavior MAY include a charset
parameter even when the charset is \%ISO-8859-1 and SHOULD do so when
it is known that it will not confuse the recipient.

Unfortunately, some older HTTP/1.0 clients did not deal properly with
an explicit charset parameter.  HTTP/1.1 recipients MUST respect the
charset label provided by the sender; and those user agents that have
a provision to "guess" a charset MUST use the charset from the
\%content-type field if they support that charset, rather than the
recipient\'s preference, when initially displaying a document.  See
Section\03.7.1.

.in 6
.ti 0
3.5.  Content Codings
.in 3

Content coding values indicate an encoding transformation that has
been or can be applied to an entity.  Content codings are primarily
used to allow a document to be compressed or otherwise usefully
transformed without losing the identity of its underlying media type
and without loss of information.  Frequently, the entity is stored in
coded form, transmitted directly, and only decoded by the recipient.
.nf

    content-coding   = token

.fi
All \%content-coding values are \%case-insensitive.  HTTP/1.1 uses
\%content-coding values in the \%Accept-Encoding (Section\014.3) and
\%Content-Encoding (Section\014.11) header fields.  Although the value
describes the \%content-coding, what is more important is that it
indicates what decoding mechanism will be required to remove the
encoding.

The Internet Assigned Numbers Authority (IANA) acts as a registry for
\%content-coding value tokens.  Initially, the registry contains the
following tokens:

gzip

.in 6
.ti 6
An encoding format produced by the file compression program "gzip"
(GNU zip) as described in RFC 1952 [25].  This format is a \%Lempel-
Ziv coding (LZ77) with a 32 bit CRC.

.in 3
compress

.in 6
.ti 6
The encoding format produced by the common UNIX file compression
program "compress".  This format is an adaptive \%Lempel-Ziv-Welch
.bp
coding (LZW).

.ti 6
Use of program names for the identification of encoding formats is
not desirable and is discouraged for future encodings.  Their use
here is representative of historical practice, not good design.
For compatibility with previous implementations of HTTP,
applications SHOULD consider \%"x-gzip" and \%"x-compress" to be
equivalent to "gzip" and "compress" respectively.

.in 3
deflate

.in 6
.ti 6
The "zlib" format defined in RFC 1950 [31] in combination with the
"deflate" compression mechanism described in RFC 1951 [29].

.in 3
identity

.in 6
.ti 6
The default (identity) encoding; the use of no transformation
whatsoever.  This \%content-coding is used only in the \%Accept-
Encoding header, and SHOULD NOT be used in the \%Content-Encoding
header.

.in 3
New \%content-coding value tokens SHOULD be registered; to allow
interoperability between clients and servers, specifications of the
content coding algorithms needed to implement a new value SHOULD be
publicly available and adequate for independent implementation, and
conform to the purpose of content coding defined in this section.

.in 6
.ti 0
3.6.  Transfer Codings
.in 3

\%Transfer-coding values are used to indicate an encoding
transformation that has been, can be, or may need to be applied to an
\%entity-body in order to ensure "safe transport" through the network.
This differs from a content coding in that the \%transfer-coding is a
property of the message, not of the original entity.
.nf

    transfer-coding         = "chunked" | transfer-extension
    transfer-extension      = token *( ";" parameter )

.fi
Parameters are in the form of attribute/value pairs.
.nf

    parameter               = attribute "=" value
    attribute               = token
    value                   = token | quoted-string

.fi
All \%transfer-coding values are \%case-insensitive.  HTTP/1.1 uses
\%transfer-coding values in the TE header field (Section\014.39) and in
the \%Transfer-Encoding header field (Section\014.41).

.bp
Whenever a \%transfer-coding is applied to a \%message-body, the set of
\%transfer-codings MUST include "chunked", unless the message is
terminated by closing the connection.  When the "chunked" \%transfer-
coding is used, it MUST be the last \%transfer-coding applied to the
\%message-body.  The "chunked" \%transfer-coding MUST NOT be applied more
than once to a \%message-body.  These rules allow the recipient to
determine the \%transfer-length of the message (Section\04.4).

\%Transfer-codings are analogous to the \%Content-Transfer-Encoding
values of MIME [7], which were designed to enable safe transport of
binary data over a \%7-bit transport service.  However, safe transport
has a different focus for an \%8bit-clean transfer protocol.  In HTTP,
the only unsafe characteristic of \%message-bodies is the difficulty in
determining the exact body length (Section\07.2.2), or the desire to
encrypt data over a shared transport.

The Internet Assigned Numbers Authority (IANA) acts as a registry for
\%transfer-coding value tokens.  Initially, the registry contains the
following tokens: "chunked" (Section\03.6.1), "identity" (section
3.6.2), "gzip" (Section\03.5), "compress" (Section\03.5), and "deflate"
(Section\03.5).

New \%transfer-coding value tokens SHOULD be registered in the same way
as new \%content-coding value tokens (Section\03.5).

A server which receives an \%entity-body with a \%transfer-coding it does
not understand SHOULD return 501 (Unimplemented), and close the
connection.  A server MUST NOT send \%transfer-codings to an HTTP/1.0
client.

.in 8
.ti 0
3.6.1.  Chunked Transfer Coding
.in 3

The chunked encoding modifies the body of a message in order to
transfer it as a series of chunks, each with its own size indicator,
followed by an OPTIONAL trailer containing \%entity-header fields.
This allows dynamically produced content to be transferred along with
the information necessary for the recipient to verify that it has
received the full message.
.bp
.nf
    Chunked-Body   = *chunk
                     last-chunk
                     trailer
                     CRLF

    chunk          = chunk-size [ chunk-extension ] CRLF
                     chunk-data CRLF
    chunk-size     = 1*HEX
    last-chunk     = 1*("0") [ chunk-extension ] CRLF

    chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
    chunk-ext-name = token
    chunk-ext-val  = token | quoted-string
    chunk-data     = chunk-size(OCTET)
    trailer        = *(entity-header CRLF)

.fi
The \%chunk-size field is a string of hex digits indicating the size of
the chunk.  The chunked encoding is ended by any chunk whose size is
zero, followed by the trailer, which is terminated by an empty line.

The trailer allows the sender to include additional HTTP header
fields at the end of the message.  The Trailer header field can be
used to indicate which header fields are included in a trailer (see
Section\014.40).

A server using chunked \%transfer-coding in a response MUST NOT use the
trailer for any header fields unless at least one of the following is
true:

.in 7
.ti 3
1.  the request included a TE header field that indicates "trailers"
is acceptable in the \%transfer-coding of the response, as
described in Section\014.39; or,

.ti 3
2.  the server is the origin server for the response, the trailer
fields consist entirely of optional metadata, and the recipient
could use the message (in a manner acceptable to the origin
server) without receiving this metadata.  In other words, the
origin server is willing to accept the possibility that the
trailer fields might be silently discarded along the path to the
client.

.in 3
This requirement prevents an interoperability failure when the
message is being received by an HTTP/1.1 (or later) proxy and
forwarded to an HTTP/1.0 recipient.  It avoids a situation where
compliance with the protocol would have necessitated a possibly
infinite buffer on the proxy.

An example process for decoding a \%Chunked-Body is presented in
.bp
Appendix\0A.4.6.

All HTTP/1.1 applications MUST be able to receive and decode the
"chunked" \%transfer-coding, and MUST ignore \%chunk-extension extensions
they do not understand.

.in 6
.ti 0
3.7.  Media Types
.in 3

HTTP uses Internet Media Types [17] in the \%Content-Type
(Section\014.17) and Accept (Section\014.1) header fields in order to
provide open and extensible data typing and type negotiation.
.nf

    media-type     = type "/" subtype *( ";" parameter )
    type           = token
    subtype        = token

.fi
Parameters MAY follow the type/subtype in the form of attribute/value
pairs (as defined in Section\03.6).

The type, subtype, and parameter attribute names are \%case-
insensitive.  Parameter values might or might not be \%case-sensitive,
depending on the semantics of the parameter name.  Linear white space
(LWS) MUST NOT be used between the type and subtype, nor between an
attribute and its value.  The presence or absence of a parameter
might be significant to the processing of a \%media-type, depending on
its definition within the media type registry.

Note that some older HTTP applications do not recognize media type
parameters.  When sending data to older HTTP applications,
implementations SHOULD only use media type parameters when they are
required by that type/subtype definition.

\%Media-type values are registered with the Internet Assigned Number
Authority (IANA [19]).  The media type registration process is
outlined in RFC 1590 [17].  Use of \%non-registered media types is
discouraged.

.in 8
.ti 0
3.7.1.  Canonicalization and Text Defaults
.in 3

Internet media types are registered with a canonical form.  An
\%entity-body transferred via HTTP messages MUST be represented in the
appropriate canonical form prior to its transmission except for
"text" types, as defined in the next paragraph.

When in canonical form, media subtypes of the "text" type use CRLF as
the text line break.  HTTP relaxes this requirement and allows the
transport of text media with plain CR or LF alone representing a line
break when it is done consistently for an entire \%entity-body.  HTTP
.bp
applications MUST accept CRLF, bare CR, and bare LF as being
representative of a line break in text media received via HTTP.  In
addition, if the text is represented in a character set that does not
use octets 13 and 10 for CR and LF respectively, as is the case for
some \%multi-byte character sets, HTTP allows the use of whatever octet
sequences are defined by that character set to represent the
equivalent of CR and LF for line breaks.  This flexibility regarding
line breaks applies only to text media in the \%entity-body; a bare CR
or LF MUST NOT be substituted for CRLF within any of the HTTP control
structures (such as header fields and multipart boundaries).

If an \%entity-body is encoded with a \%content-coding, the underlying
data MUST be in a form defined above prior to being encoded.

The "charset" parameter is used with some media types to define the
character set (Section\03.4) of the data.  When no explicit charset
parameter is provided by the sender, media subtypes of the "text"
type are defined to have a default charset value of \%"ISO-8859-1" when
received via HTTP.  Data in character sets other than \%"ISO-8859-1" or
its subsets MUST be labeled with an appropriate charset value.  See
Section\03.4.1 for compatibility problems.

.in 8
.ti 0
3.7.2.  Multipart Types
.in 3

MIME provides for a number of "multipart" types \%-- encapsulations of
one or more entities within a single \%message-body.  All multipart
types share a common syntax, as defined in section 5.1.1 of RFC 2046
[40], and MUST include a boundary parameter as part of the media type
value.  The message body is itself a protocol element and MUST
therefore use only CRLF to represent line breaks between \%body-parts.
Unlike in RFC 2046, the epilogue of any multipart message MUST be
empty; HTTP applications MUST NOT transmit the epilogue (even if the
original multipart contains an epilogue).  These restrictions exist
in order to preserve the \%self-delimiting nature of a multipart
\%message-body, wherein the "end" of the \%message-body is indicated by
the ending multipart boundary.

In general, HTTP treats a multipart \%message-body no differently than
any other media type: strictly as payload.  The one exception is the
"multipart/byteranges" type (Appendix\0A.2) when it appears in a 206
(Partial Content) response, which will be interpreted by some HTTP
caching mechanisms as described in sections 13.5.4 and 14.16.  In all
other cases, an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type.
The MIME header fields within each \%body-part of a multipart \%message-
body do not have any significance to HTTP beyond that defined by
their MIME semantics.

.bp
In general, an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type.
If an application receives an unrecognized multipart subtype, the
application MUST treat it as being equivalent to "multipart/mixed".

.in 6
.ti 6
Note: The \%"multipart/form-data" type has been specifically defined
for carrying form data suitable for processing via the POST
request method, as described in RFC 1867 [15].

.in 3
.in 6
.ti 0
3.8.  Product Tokens
.in 3

Product tokens are used to allow communicating applications to
identify themselves by software name and version.  Most fields using
product tokens also allow \%sub-products which form a significant part
of the application to be listed, separated by white space.  By
convention, the products are listed in order of their significance
for identifying the application.
.nf

    product         = token ["/" product-version]
    product-version = token

.fi
Examples:
.nf

    User-Agent: CERN-LineMode/2.15 libwww/2.17b3
    Server: Apache/0.8.4

.fi
Product tokens SHOULD be short and to the point.  They MUST NOT be
used for advertising or other \%non-essential information.  Although
any token character MAY appear in a \%product-version, this token
SHOULD only be used for a version identifier (i.e., successive
versions of the same product SHOULD only differ in the \%product-
version portion of the product value).

.in 6
.ti 0
3.9.  Quality Values
.in 3

HTTP content negotiation (Section\012) uses short "floating point"
numbers to indicate the relative importance ("weight") of various
negotiable parameters.  A weight is normalized to a real number in
the range 0 through 1, where 0 is the minimum and 1 the maximum
value.  If a parameter has a quality value of 0, then content with
this parameter is `not acceptable\' for the client.  HTTP/1.1
applications MUST NOT generate more than three digits after the
decimal point.  User configuration of these values SHOULD also be
limited in this fashion.
.nf

    qvalue         = ( "0" [ "." 0*3DIGIT ] )
                   | ( "1" [ "." 0*3("0") ] )

.bp
.fi
"Quality values" is a misnomer, since these values merely represent
relative degradation in desired quality.

.in 7
.ti 0
3.10.  Language Tags
.in 3

A language tag identifies a natural language spoken, written, or
otherwise conveyed by human beings for communication of information
to other human beings.  Computer languages are explicitly excluded.
HTTP uses language tags within the \%Accept-Language and \%Content-
Language fields.

The syntax and registry of HTTP language tags is the same as that
defined by RFC 1766 [1].  In summary, a language tag is composed of 1
or more parts: A primary language tag and a possibly empty series of
subtags:
.nf

     language-tag  = primary-tag *( "-" subtag )
     primary-tag   = 1*8ALPHA
     subtag        = 1*8ALPHA

.fi
White space is not allowed within the tag and all tags are \%case-
insensitive.  The name space of language tags is administered by the
IANA.  Example tags include:
.nf

    en, en-US, en-cockney, i-cherokee, x-pig-latin

.fi
where any \%two-letter \%primary-tag is an \%ISO-639 language abbreviation
and any \%two-letter initial subtag is an \%ISO-3166 country code.  (The
last three tags above are not registered tags; all but the last are
examples of tags which could be registered in future.)

.in 7
.ti 0
3.11.  Entity Tags
.in 3

Entity tags are used for comparing two or more entities from the same
requested resource.  HTTP/1.1 uses entity tags in the ETag
(Section\014.19), \%If-Match (Section\014.24), \%If-None-Match
(Section\014.26), and \%If-Range (Section\014.27) header fields.  The
definition of how they are used and compared as cache validators is
in Section\013.3.3.  An entity tag consists of an opaque quoted
string, possibly prefixed by a weakness indicator.
.nf

   entity-tag = [ weak ] opaque-tag
   weak       = "W/"
   opaque-tag = quoted-string

.fi
A "strong entity tag" MAY be shared by two entities of a resource
only if they are equivalent by octet equality.

.bp
A "weak entity tag," indicated by the "W/" prefix, MAY be shared by
two entities of a resource only if the entities are equivalent and
could be substituted for each other with no significant change in
semantics.  A weak entity tag can only be used for weak comparison.

An entity tag MUST be unique across all versions of all entities
associated with a particular resource.  A given entity tag value MAY
be used for entities obtained by requests on different URIs.  The use
of the same entity tag value in conjunction with entities obtained by
requests on different URIs does not imply the equivalence of those
entities.

.in 7
.ti 0
3.12.  Range Units
.in 3

HTTP/1.1 allows a client to request that only part (a range of) the
response entity be included within the response.  HTTP/1.1 uses range
units in the Range (Section\014.35) and \%Content-Range (Section\014.16)
header fields.  An entity can be broken down into subranges according
to various structural units.
.nf

   range-unit       = bytes-unit | other-range-unit
   bytes-unit       = "bytes"
   other-range-unit = token

.fi
The only range unit defined by HTTP/1.1 is "bytes".  HTTP/1.1
implementations MAY ignore ranges specified using other units.

HTTP/1.1 has been designed to allow implementations of applications
that do not depend on knowledge of ranges.
.bp
.in 4
.ti 0
4.  HTTP Message
.in 3

.in 6
.ti 0
4.1.  Message Types
.in 3

HTTP messages consist of requests from client to server and responses
from server to client.
.nf

    HTTP-message   = Request | Response     ; HTTP/1.1 messages

.fi
Request (Section\05) and Response (Section\06) messages use the generic
message format of RFC 822 [9] for transferring entities (the payload
of the message).  Both types of message consist of a \%start-line, zero
or more header fields (also known as "headers"), an empty line (i.e.,
a line with nothing preceding the CRLF) indicating the end of the
header fields, and possibly a \%message-body.
.nf

     generic-message = start-line
                       *(message-header CRLF)
                       CRLF
                       [ message-body ]
     start-line      = Request-Line | Status-Line

.fi
In the interest of robustness, servers SHOULD ignore any empty
line(s) received where a \%Request-Line is expected.  In other words,
if the server is reading the protocol stream at the beginning of a
message and receives a CRLF first, it should ignore the CRLF.

Certain buggy HTTP/1.0 client implementations generate extra CRLF\'s
after a POST request.  To restate what is explicitly forbidden by the
BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an
extra CRLF.

.in 6
.ti 0
4.2.  Message Headers
.in 3

HTTP header fields, which include \%general-header (Section\04.5),
\%request-header (Section\05.3), \%response-header (Section\06.2), and
\%entity-header (Section\07.1) fields, follow the same generic format as
that given in Section 3.1 of RFC 822 [9].  Each header field consists
of a name followed by a colon (":") and the field value.  Field names
are \%case-insensitive.  The field value MAY be preceded by any amount
of LWS, though a single SP is preferred.  Header fields can be
extended over multiple lines by preceding each extra line with at
least one SP or HT.  Applications ought to follow "common form",
where one is known or indicated, when generating HTTP constructs,
since there might exist some implementations that fail to accept
anything beyond the common forms.
.bp
.nf
    message-header = field-name ":" [ field-value ]
    field-name     = token
    field-value    = *( field-content | LWS )
    field-content  = <the OCTETs making up the field-value
                     and consisting of either *TEXT or combinations
                     of token, separators, and quoted-string>

.fi
The \%field-content does not include any leading or trailing LWS:
linear white space occurring before the first \%non-whitespace
character of the \%field-value or after the last \%non-whitespace
character of the \%field-value.  Such leading or trailing LWS MAY be
removed without changing the semantics of the field value.  Any LWS
that occurs between \%field-content MAY be replaced with a single SP
before interpreting the field value or forwarding the message
downstream.

The order in which header fields with differing field names are
received is not significant.  However, it is "good practice" to send
\%general-header fields first, followed by \%request-header or \%response-
header fields, and ending with the \%entity-header fields.

Multiple \%message-header fields with the same \%field-name MAY be
present in a message if and only if the entire \%field-value for that
header field is defined as a \%comma-separated list [i.e., #(values)].
It MUST be possible to combine the multiple header fields into one
\%"field-name: \%field-value" pair, without changing the semantics of the
message, by appending each subsequent \%field-value to the first, each
separated by a comma.  The order in which header fields with the same
\%field-name are received is therefore significant to the
interpretation of the combined field value, and thus a proxy MUST NOT
change the order of these field values when a message is forwarded.

.in 6
.ti 0
4.3.  Message Body
.in 3

The \%message-body (if any) of an HTTP message is used to carry the
\%entity-body associated with the request or response.  The \%message-
body differs from the \%entity-body only when a \%transfer-coding has
been applied, as indicated by the \%Transfer-Encoding header field
(Section\014.41).
.nf

    message-body = entity-body
                 | <entity-body encoded as per Transfer-Encoding>

.fi
\%Transfer-Encoding MUST be used to indicate any \%transfer-codings
applied by an application to ensure safe and proper transfer of the
message.  \%Transfer-Encoding is a property of the message, not of the
entity, and thus MAY be added or removed by any application along the
request/response chain.  (However, Section\03.6 places restrictions on
.bp
when certain \%transfer-codings may be used.)

The rules for when a \%message-body is allowed in a message differ for
requests and responses.

The presence of a \%message-body in a request is signaled by the
inclusion of a \%Content-Length or \%Transfer-Encoding header field in
the request\'s \%message-headers.  A \%message-body MUST NOT be included
in a request if the specification of the request method
(Section\05.1.1) does not allow sending an \%entity-body in requests.  A
server SHOULD read and forward a \%message-body on any request; if the
request method does not include defined semantics for an \%entity-body,
then the \%message-body SHOULD be ignored when handling the request.

For response messages, whether or not a \%message-body is included with
a message is dependent on both the request method and the response
status code (Section\06.1.1).  All responses to the HEAD request
method MUST NOT include a \%message-body, even though the presence of
\%entity-header fields might lead one to believe they do.  All 1xx
(informational), 204 (no content), and 304 (not modified) responses
MUST NOT include a \%message-body.  All other responses do include a
\%message-body, although it MAY be of zero length.

.in 6
.ti 0
4.4.  Message Length
.in 3

The \%transfer-length of a message is the length of the \%message-body as
it appears in the message; that is, after any \%transfer-codings have
been applied.  When a \%message-body is included with a message, the
\%transfer-length of that body is determined by one of the following
(in order of precedence):

.in 7
.ti 3
1.  Any response message which "MUST NOT" include a \%message-body
(such as the 1xx, 204, and 304 responses and any response to a
HEAD request) is always terminated by the first empty line after
the header fields, regardless of the \%entity-header fields present
in the message.

.ti 3
2.  If a \%Transfer-Encoding header field (Section\014.41) is present
and has any value other than "identity", then the \%transfer-length
is defined by use of the "chunked" \%transfer-coding (Section\03.6),
unless the message is terminated by closing the connection.

.ti 3
3.  If a \%Content-Length header field (Section\014.13) is present, its
decimal value in OCTETs represents both the \%entity-length and the
\%transfer-length.  The \%Content-Length header field MUST NOT be
sent if these two lengths are different (i.e., if a \%Transfer-
Encoding header field is present).  If a message is received with
both a \%Transfer-Encoding header field and a \%Content-Length header
.bp
field, the latter MUST be ignored.

.ti 3
4.  If the message uses the media type "multipart/byteranges", and
the \%ransfer-length is not otherwise specified, then this \%self-
elimiting media type defines the \%transfer-length.  This media
type UST NOT be used unless the sender knows that the recipient
can arse it; the presence in a request of a Range header with
ultiple \%byte-range specifiers from a 1.1 client implies that the
lient can parse multipart/byteranges responses.

.in 10
.ti 10
A range header might be forwarded by a 1.0 proxy that does not
understand multipart/byteranges; in this case the server MUST
delimit the message using methods defined in items 1, 3 or 5
of this section.

.in 7
.ti 3
5.  By the server closing the connection.  (Closing the connection
cannot be used to indicate the end of a request body, since that
would leave no possibility for the server to send back a
response.)

.in 3
For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
containing a \%message-body MUST include a valid \%Content-Length header
field unless the server is known to be HTTP/1.1 compliant.  If a
request contains a \%message-body and a \%Content-Length is not given,
the server SHOULD respond with 400 (bad request) if it cannot
determine the length of the message, or with 411 (length required) if
it wishes to insist on receiving a valid \%Content-Length.

All HTTP/1.1 applications that receive entities MUST accept the
"chunked" \%transfer-coding (Section\03.6), thus allowing this mechanism
to be used for messages when the message length cannot be determined
in advance.

Messages MUST NOT include both a \%Content-Length header field and a
\%non-identity \%transfer-coding.  If the message does include a \%non-
identity \%transfer-coding, the \%Content-Length MUST be ignored.

When a \%Content-Length is given in a message where a \%message-body is
allowed, its field value MUST exactly match the number of OCTETs in
the \%message-body.  HTTP/1.1 user agents MUST notify the user when an
invalid length is received and detected.

.in 6
.ti 0
4.5.  General Header Fields
.in 3

There are a few header fields which have general applicability for
both request and response messages, but which do not apply to the
entity being transferred.  These header fields apply only to the
message being transmitted.
.bp
.nf
    general-header = Cache-Control            ; Section 14.9
                   | Connection               ; Section 14.10
                   | Date                     ; Section 14.18
                   | Pragma                   ; Section 14.32
                   | Trailer                  ; Section 14.40
                   | Transfer-Encoding        ; Section 14.41
                   | Upgrade                  ; Section 14.42
                   | Via                      ; Section 14.45
                   | Warning                  ; Section 14.46

.fi
\%General-header field names can be extended reliably only in
combination with a change in the protocol version.  However, new or
experimental header fields may be given the semantics of general
header fields if all parties in the communication recognize them to
be \%general-header fields.  Unrecognized header fields are treated as
\%entity-header fields.
.bp
.in 4
.ti 0
5.  Request
.in 3

A request message from a client to a server includes, within the
first line of that message, the method to be applied to the resource,
the identifier of the resource, and the protocol version in use.
.nf

     Request       = Request-Line              ; Section 5.1
                     *(( general-header        ; Section 4.5
                      | request-header         ; Section 5.3
                      | entity-header ) CRLF)  ; Section 7.1
                     CRLF
                     [ message-body ]          ; Section 4.3

.fi
.in 6
.ti 0
5.1.  \%Request-Line
.in 3

The \%Request-Line begins with a method token, followed by the \%Request-
URI and the protocol version, and ending with CRLF.  The elements are
separated by SP characters.  No CR or LF is allowed except in the
final CRLF sequence.
.nf

     Request-Line   = Method SP Request-URI SP HTTP-Version CRLF

.fi
.in 8
.ti 0
5.1.1.  Method
.in 3

The Method token indicates the method to be performed on the resource
identified by the \%Request-URI.  The method is \%case-sensitive.
.nf

    Method         = "OPTIONS"                ; Section 9.2
                   | "GET"                    ; Section 9.3
                   | "HEAD"                   ; Section 9.4
                   | "POST"                   ; Section 9.5
                   | "PUT"                    ; Section 9.6
                   | "DELETE"                 ; Section 9.7
                   | "TRACE"                  ; Section 9.8
                   | "CONNECT"                ; Section 9.9
                   | extension-method
    extension-method = token

.fi
The list of methods allowed by a resource can be specified in an
Allow header field (Section\014.7).  The return code of the response
always notifies the client whether a method is currently allowed on a
resource, since the set of allowed methods can change dynamically.
An origin server SHOULD return the status code 405 (Method Not
Allowed) if the method is known by the origin server but not allowed
for the requested resource, and 501 (Not Implemented) if the method
is unrecognized or not implemented by the origin server.  The methods
GET and HEAD MUST be supported by all \%general-purpose servers.  All
other methods are OPTIONAL; however, if the above methods are
.bp
implemented, they MUST be implemented with the same semantics as
those specified in Section\09.

.in 8
.ti 0
5.1.2.  \%Request-URI
.in 3

The \%Request-URI is a Uniform Resource Identifier (Section\03.2) and
identifies the resource upon which to apply the request.
.nf

    Request-URI    = "*" | absoluteURI | abs_path | authority

.fi
The four options for \%Request-URI are dependent on the nature of the
request.  The asterisk "*" means that the request does not apply to a
particular resource, but to the server itself, and is only allowed
when the method used does not necessarily apply to a resource.  One
example would be
.nf

    OPTIONS * HTTP/1.1

.fi
The absoluteURI form is REQUIRED when the request is being made to a
proxy.  The proxy is requested to forward the request or service it
from a valid cache, and return the response.  Note that the proxy MAY
forward the request on to another proxy or directly to the server
specified by the absoluteURI.  In order to avoid request loops, a
proxy MUST be able to recognize all of its server names, including
any aliases, local variations, and the numeric IP address.  An
example \%Request-Line would be:
.nf

    GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1

.fi
To allow for transition to absoluteURIs in all requests in future
versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
form in requests, even though HTTP/1.1 clients will only generate
them in requests to proxies.

The authority form is only used by the CONNECT method (Section\09.9).

The most common form of \%Request-URI is that used to identify a
resource on an origin server or gateway.  In this case the absolute
path of the URI MUST be transmitted (see Section\03.2.1, abs_path) as
the \%Request-URI, and the network location of the URI (authority) MUST
be transmitted in a Host header field.  For example, a client wishing
to retrieve the resource above directly from the origin server would
create a TCP connection to port 80 of the host "www.w3.org" and send
the lines:
.nf

    GET /pub/WWW/TheProject.html HTTP/1.1
    Host: www.w3.org

.bp
.fi
followed by the remainder of the Request.  Note that the absolute
path cannot be empty; if none is present in the original URI, it MUST
be given as "/" (the server root).

The \%Request-URI is transmitted in the format specified in
Section\03.2.1.  If the \%Request-URI is encoded using the "% HEX HEX"
encoding [42], the origin server MUST decode the \%Request-URI in order
to properly interpret the request.  Servers SHOULD respond to invalid
\%Request-URIs with an appropriate status code.

A transparent proxy MUST NOT rewrite the "abs_path" part of the
received \%Request-URI when forwarding it to the next inbound server,
except as noted above to replace a null abs_path with "/".

.in 6
.ti 6
Note: The "no rewrite" rule prevents the proxy from changing the
meaning of the request when the origin server is improperly using
a \%non-reserved URI character for a reserved purpose.  Implementors
should be aware that some \%pre-HTTP/1.1 proxies have been known to
rewrite the \%Request-URI.

.in 3
.in 6
.ti 0
5.2.  The Resource Identified by a Request
.in 3

The exact resource identified by an Internet request is determined by
examining both the \%Request-URI and the Host header field.

An origin server that does not allow resources to differ by the
requested host MAY ignore the Host header field value when
determining the resource identified by an HTTP/1.1 request.  (But see
Appendix\0A.6.1.1 for other requirements on Host support in HTTP/1.1.)

An origin server that does differentiate resources based on the host
requested (sometimes referred to as virtual hosts or vanity host
names) MUST use the following rules for determining the requested
resource on an HTTP/1.1 request:

.in 7
.ti 3
1.  If \%Request-URI is an absoluteURI, the host is part of the
\%Request-URI.  Any Host header field value in the request MUST be
ignored.

.ti 3
2.  If the \%Request-URI is not an absoluteURI, and the request
includes a Host header field, the host is determined by the Host
header field value.

.ti 3
3.  If the host as determined by rule 1 or 2 is not a valid host on
the server, the response MUST be a 400 (Bad Request) error
message.

.in 3
Recipients of an HTTP/1.0 request that lacks a Host header field MAY
.bp
attempt to use heuristics (e.g., examination of the URI path for
something unique to a particular host) in order to determine what
exact resource is being requested.

.in 6
.ti 0
5.3.  Request Header Fields
.in 3

The \%request-header fields allow the client to pass additional
information about the request, and about the client itself, to the
server.  These fields act as request modifiers, with semantics
equivalent to the parameters on a programming language method
invocation.
.nf

    request-header = Accept                   ; Section 14.1
                   | Accept-Charset           ; Section 14.2
                   | Accept-Encoding          ; Section 14.3
                   | Accept-Language          ; Section 14.4
                   | Authorization            ; Section 14.8
                   | Expect                   ; Section 14.20
                   | From                     ; Section 14.22
                   | Host                     ; Section 14.23
                   | If-Match                 ; Section 14.24
                   | If-Modified-Since        ; Section 14.25
                   | If-None-Match            ; Section 14.26
                   | If-Range                 ; Section 14.27
                   | If-Unmodified-Since      ; Section 14.28
                   | Max-Forwards             ; Section 14.31
                   | Proxy-Authorization      ; Section 14.34
                   | Range                    ; Section 14.35
                   | Referer                  ; Section 14.36
                   | TE                       ; Section 14.39
                   | User-Agent               ; Section 14.43

.fi
\%Request-header field names can be extended reliably only in
combination with a change in the protocol version.  However, new or
experimental header fields MAY be given the semantics of \%request-
header fields if all parties in the communication recognize them to
be \%request-header fields.  Unrecognized header fields are treated as
\%entity-header fields.
.bp
.in 4
.ti 0
6.  Response
.in 3

After receiving and interpreting a request message, a server responds
with an HTTP response message.
.nf

    Response      = Status-Line               ; Section 6.1
                    *(( general-header        ; Section 4.5
                     | response-header        ; Section 6.2
                     | entity-header ) CRLF)  ; Section 7.1
                    CRLF
                    [ message-body ]          ; Section 7.2

.fi
.in 6
.ti 0
6.1.  \%Status-Line
.in 3

The first line of a Response message is the \%Status-Line, consisting
of the protocol version followed by a numeric status code and its
associated textual phrase, with each element separated by SP
characters.  No CR or LF is allowed except in the final CRLF
sequence.
.nf

    Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF

.fi
.in 8
.ti 0
6.1.1.  Status Code and Reason Phrase
.in 3

The \%Status-Code element is a \%3-digit integer result code of the
attempt to understand and satisfy the request.  These codes are fully
defined in Section\010.  The \%Reason-Phrase is intended to give a short
textual description of the \%Status-Code.  The \%Status-Code is intended
for use by automata and the \%Reason-Phrase is intended for the human
user.  The client is not required to examine or display the \%Reason-
Phrase.

The first digit of the \%Status-Code defines the class of response.
The last two digits do not have any categorization role.  There are 5
values for the first digit:

.in 6
.ti 3
o  1xx: Informational \%- Request received, continuing process

.ti 3
o  2xx: Success \%- The action was successfully received, understood,
and accepted

.ti 3
o  3xx: Redirection \%- Further action must be taken in order to
complete the request

.ti 3
o  4xx: Client Error \%- The request contains bad syntax or cannot be
fulfilled
.bp
.ti 3
o  5xx: Server Error \%- The server failed to fulfill an apparently
valid request

.in 3
The individual values of the numeric status codes defined for
HTTP/1.1, and an example set of corresponding \%Reason-Phrase\'s, are
presented below.  The reason phrases listed here are only
recommendations \%-- they MAY be replaced by local equivalents without
affecting the protocol.
.bp
.nf
   Status-Code    =
         "100"  ; Section 10.1.1: Continue
       | "101"  ; Section 10.1.2: Switching Protocols
       | "200"  ; Section 10.2.1: OK
       | "201"  ; Section 10.2.2: Created
       | "202"  ; Section 10.2.3: Accepted
       | "203"  ; Section 10.2.4: Non-Authoritative Information
       | "204"  ; Section 10.2.5: No Content
       | "205"  ; Section 10.2.6: Reset Content
       | "206"  ; Section 10.2.7: Partial Content
       | "300"  ; Section 10.3.1: Multiple Choices
       | "301"  ; Section 10.3.2: Moved Permanently
       | "302"  ; Section 10.3.3: Found
       | "303"  ; Section 10.3.4: See Other
       | "304"  ; Section 10.3.5: Not Modified
       | "305"  ; Section 10.3.6: Use Proxy
       | "307"  ; Section 10.3.8: Temporary Redirect
       | "400"  ; Section 10.4.1: Bad Request
       | "401"  ; Section 10.4.2: Unauthorized
       | "402"  ; Section 10.4.3: Payment Required
       | "403"  ; Section 10.4.4: Forbidden
       | "404"  ; Section 10.4.5: Not Found
       | "405"  ; Section 10.4.6: Method Not Allowed
       | "406"  ; Section 10.4.7: Not Acceptable
       | "407"  ; Section 10.4.8: Proxy Authentication Required
       | "408"  ; Section 10.4.9: Request Time-out
       | "409"  ; Section 10.4.10: Conflict
       | "410"  ; Section 10.4.11: Gone
       | "411"  ; Section 10.4.12: Length Required
       | "412"  ; Section 10.4.13: Precondition Failed
       | "413"  ; Section 10.4.14: Request Entity Too Large
       | "414"  ; Section 10.4.15: Request-URI Too Large
       | "415"  ; Section 10.4.16: Unsupported Media Type
       | "416"  ; Section 10.4.17: Requested range not satisfiable
       | "417"  ; Section 10.4.18: Expectation Failed
       | "500"  ; Section 10.5.1: Internal Server Error
       | "501"  ; Section 10.5.2: Not Implemented
       | "502"  ; Section 10.5.3: Bad Gateway
       | "503"  ; Section 10.5.4: Service Unavailable
       | "504"  ; Section 10.5.5: Gateway Time-out
       | "505"  ; Section 10.5.6: HTTP Version not supported
       | extension-code

   extension-code = 3DIGIT
   Reason-Phrase  = *<TEXT, excluding CR, LF>

.fi
HTTP status codes are extensible.  HTTP applications are not required
to understand the meaning of all registered status codes, though such
.bp
understanding is obviously desirable.  However, applications MUST
understand the class of any status code, as indicated by the first
digit, and treat any unrecognized response as being equivalent to the
x00 status code of that class, with the exception that an
unrecognized response MUST NOT be cached.  For example, if an
unrecognized status code of 431 is received by the client, it can
safely assume that there was something wrong with its request and
treat the response as if it had received a 400 status code.  In such
cases, user agents SHOULD present to the user the entity returned
with the response, since that entity is likely to include \%human-
readable information which will explain the unusual status.

.in 6
.ti 0
6.2.  Response Header Fields
.in 3

The \%response-header fields allow the server to pass additional
information about the response which cannot be placed in the \%Status-
Line.  These header fields give information about the server and
about further access to the resource identified by the \%Request-URI.
.nf

    response-header = Accept-Ranges           ; Section 14.5
                    | Age                     ; Section 14.6
                    | ETag                    ; Section 14.19
                    | Location                ; Section 14.30
                    | Proxy-Authenticate      ; Section 14.33
                    | Retry-After             ; Section 14.37
                    | Server                  ; Section 14.38
                    | Vary                    ; Section 14.44
                    | WWW-Authenticate        ; Section 14.47

.fi
\%Response-header field names can be extended reliably only in
combination with a change in the protocol version.  However, new or
experimental header fields MAY be given the semantics of \%response-
header fields if all parties in the communication recognize them to
be \%response-header fields.  Unrecognized header fields are treated as
\%entity-header fields.
.bp
.in 4
.ti 0
7.  Entity
.in 3

Request and Response messages MAY transfer an entity if not otherwise
restricted by the request method or response status code.  An entity
consists of \%entity-header fields and an \%entity-body, although some
responses will only include the \%entity-headers.

In this section, both sender and recipient refer to either the client
or the server, depending on who sends and who receives the entity.

.in 6
.ti 0
7.1.  Entity Header Fields
.in 3

\%Entity-header fields define metainformation about the \%entity-body or,
if no body is present, about the resource identified by the request.
Some of this metainformation is OPTIONAL; some might be REQUIRED by
portions of this specification.
.nf

    entity-header  = Allow                    ; Section 14.7
                   | Content-Encoding         ; Section 14.11
                   | Content-Language         ; Section 14.12
                   | Content-Length           ; Section 14.13
                   | Content-Location         ; Section 14.14
                   | Content-MD5              ; Section 14.15
                   | Content-Range            ; Section 14.16
                   | Content-Type             ; Section 14.17
                   | Expires                  ; Section 14.21
                   | Last-Modified            ; Section 14.29
                   | extension-header

    extension-header = message-header

.fi
The \%extension-header mechanism allows additional \%entity-header fields
to be defined without changing the protocol, but these fields cannot
be assumed to be recognizable by the recipient.  Unrecognized header
fields SHOULD be ignored by the recipient and MUST be forwarded by
transparent proxies.

.in 6
.ti 0
7.2.  Entity Body
.in 3

The \%entity-body (if any) sent with an HTTP request or response is in
a format and encoding defined by the \%entity-header fields.
.nf

    entity-body    = *OCTET

.fi
An \%entity-body is only present in a message when a \%message-body is
present, as described in Section\04.3.  The \%entity-body is obtained
from the \%message-body by decoding any \%Transfer-Encoding that might
have been applied to ensure safe and proper transfer of the message.
.bp
.in 8
.ti 0
7.2.1.  Type
.in 3

When an \%entity-body is included with a message, the data type of that
body is determined via the header fields \%Content-Type and \%Content-
Encoding.  These define a \%two-layer, ordered encoding model:
.nf

    entity-body := Content-Encoding( Content-Type( data ) )

.fi
\%Content-Type specifies the media type of the underlying data.
\%Content-Encoding may be used to indicate any additional content
codings applied to the data, usually for the purpose of data
compression, that are a property of the requested resource.  There is
no default encoding.

Any HTTP/1.1 message containing an \%entity-body SHOULD include a
\%Content-Type header field defining the media type of that body.  If
and only if the media type is not given by a \%Content-Type field, the
recipient MAY attempt to guess the media type via inspection of its
content and/or the name extension(s) of the URI used to identify the
resource.  If the media type remains unknown, the recipient SHOULD
treat it as type \%"application/octet-stream".

.in 8
.ti 0
7.2.2.  Entity Length
.in 3

The \%entity-length of a message is the length of the \%message-body
before any \%transfer-codings have been applied.  Section\04.4 defines
how the \%transfer-length of a \%message-body is determined.
.bp
.in 4
.ti 0
8.  Connections
.in 3

.in 6
.ti 0
8.1.  Persistent Connections
.in 3

.in 8
.ti 0
8.1.1.  Purpose
.in 3

Prior to persistent connections, a separate TCP connection was
established to fetch each URL, increasing the load on HTTP servers
and causing congestion on the Internet.  The use of inline images and
other associated data often require a client to make multiple
requests of the same server in a short amount of time.  Analysis of
these performance problems and results from a prototype
implementation are available [26] [30].  Implementation experience
and measurements of actual HTTP/1.1 (RFC 2068) implementations show
good results [39].  Alternatives have also been explored, for
example, T/TCP [27].

Persistent HTTP connections have a number of advantages:

.in 6
.ti 3
o  By opening and closing fewer TCP connections, CPU time is saved in
routers and hosts (clients, servers, proxies, gateways, tunnels,
or caches), and memory used for TCP protocol control blocks can be
saved in hosts.

.ti 3
o  HTTP requests and responses can be pipelined on a connection.
Pipelining allows a client to make multiple requests without
waiting for each response, allowing a single TCP connection to be
used much more efficiently, with much lower elapsed time.

.ti 3
o  Network congestion is reduced by reducing the number of packets
caused by TCP opens, and by allowing TCP sufficient time to
determine the congestion state of the network.

.ti 3
o  Latency on subsequent requests is reduced since there is no time
spent in TCP\'s connection opening handshake.

.ti 3
o  HTTP can evolve more gracefully, since errors can be reported
without the penalty of closing the TCP connection.  Clients using
future versions of HTTP might optimistically try a new feature,
but if communicating with an older server, retry with old
semantics after an error is reported.

.in 3
HTTP implementations SHOULD implement persistent connections.

.in 8
.ti 0
8.1.2.  Overall Operation
.in 3

A significant difference between HTTP/1.1 and earlier versions of
HTTP is that persistent connections are the default behavior of any
.bp
HTTP connection.  That is, unless otherwise indicated, the client
SHOULD assume that the server will maintain a persistent connection,
even after error responses from the server.

Persistent connections provide a mechanism by which a client and a
server can signal the close of a TCP connection.  This signaling
takes place using the Connection header field (Section\014.10).  Once
a close has been signaled, the client MUST NOT send any more requests
on that connection.

.in 10
.ti 0
8.1.2.1.  Negotiation
.in 3

An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to
maintain a persistent connection unless a Connection header including
the \%connection-token "close" was sent in the request.  If the server
chooses to close the connection immediately after sending the
response, it SHOULD send a Connection header including the
\%connection-token close.

An HTTP/1.1 client MAY expect a connection to remain open, but would
decide to keep it open based on whether the response from a server
contains a Connection header with the \%connection-token close.  In
case the client does not want to maintain a connection for more than
that request, it SHOULD send a Connection header including the
\%connection-token close.

If either the client or the server sends the close token in the
Connection header, that request becomes the last one for the
connection.

Clients and servers SHOULD NOT assume that a persistent connection is
maintained for HTTP versions less than 1.1 unless it is explicitly
signaled.  See Appendix\0A.6.2 for more information on backward
compatibility with HTTP/1.0 clients.

In order to remain persistent, all messages on the connection MUST
have a \%self-defined message length (i.e., one not defined by closure
of the connection), as described in Section\04.4.

.in 10
.ti 0
8.1.2.2.  Pipelining
.in 3

A client that supports persistent connections MAY "pipeline" its
requests (i.e., send multiple requests without waiting for each
response).  A server MUST send its responses to those requests in the
same order that the requests were received.

Clients which assume persistent connections and pipeline immediately
after connection establishment SHOULD be prepared to retry their
.bp
connection if the first pipelined attempt fails.  If a client does
such a retry, it MUST NOT pipeline before it knows the connection is
persistent.  Clients MUST also be prepared to resend their requests
if the server closes the connection before sending all of the
corresponding responses.

Clients SHOULD NOT pipeline requests using \%non-idempotent methods or
\%non-idempotent sequences of methods (see Section\09.1.2).  Otherwise,
a premature termination of the transport connection could lead to
indeterminate results.  A client wishing to send a \%non-idempotent
request SHOULD wait to send that request until it has received the
response status for the previous request.

.in 8
.ti 0
8.1.3.  Proxy Servers
.in 3

It is especially important that proxies correctly implement the
properties of the Connection header field as specified in
Section\014.10.

The proxy server MUST signal persistent connections separately with
its clients and the origin servers (or other proxy servers) that it
connects to.  Each persistent connection applies to only one
transport link.

A proxy server MUST NOT establish a HTTP/1.1 persistent connection
with an HTTP/1.0 client (but see RFC 2068 [33] for information and
discussion of the problems with the \%Keep-Alive header implemented by
many HTTP/1.0 clients).

.in 8
.ti 0
8.1.4.  Practical Considerations
.in 3

Servers will usually have some \%time-out value beyond which they will
no longer maintain an inactive connection.  Proxy servers might make
this a higher value since it is likely that the client will be making
more connections through the same server.  The use of persistent
connections places no requirements on the length (or existence) of
this \%time-out for either the client or the server.

When a client or server wishes to \%time-out it SHOULD issue a graceful
close on the transport connection.  Clients and servers SHOULD both
constantly watch for the other side of the transport close, and
respond to it as appropriate.  If a client or server does not detect
the other side\'s close promptly it could cause unnecessary resource
drain on the network.

A client, server, or proxy MAY close the transport connection at any
time.  For example, a client might have started to send a new request
at the same time that the server has decided to close the "idle"
.bp
connection.  From the server\'s point of view, the connection is being
closed while it was idle, but from the client\'s point of view, a
request is in progress.

This means that clients, servers, and proxies MUST be able to recover
from asynchronous close events.  Client software SHOULD reopen the
transport connection and retransmit the aborted sequence of requests
without user interaction so long as the request sequence is
idempotent (see Section\09.1.2).  \%Non-idempotent methods or sequences
MUST NOT be automatically retried, although user agents MAY offer a
human operator the choice of retrying the request(s).  Confirmation
by \%user-agent software with semantic understanding of the application
MAY substitute for user confirmation.  The automatic retry SHOULD NOT
be repeated if the second sequence of requests fails.

Servers SHOULD always respond to at least one request per connection,
if at all possible.  Servers SHOULD NOT close a connection in the
middle of transmitting a response, unless a network or client failure
is suspected.

Clients that use persistent connections SHOULD limit the number of
simultaneous connections that they maintain to a given server.  A
\%single-user client SHOULD NOT maintain more than 2 connections with
any server or proxy.  A proxy SHOULD use up to 2*N connections to
another server or proxy, where N is the number of simultaneously
active users.  These guidelines are intended to improve HTTP response
times and avoid congestion.

.in 6
.ti 0
8.2.  Message Transmission Requirements
.in 3

.in 8
.ti 0
8.2.1.  Persistent Connections and Flow Control
.in 3

HTTP/1.1 servers SHOULD maintain persistent connections and use TCP\'s
flow control mechanisms to resolve temporary overloads, rather than
terminating connections with the expectation that clients will retry.
The latter technique can exacerbate network congestion.

.in 8
.ti 0
8.2.2.  Monitoring Connections for Error Status Messages
.in 3

An HTTP/1.1 (or later) client sending a \%message-body SHOULD monitor
the network connection for an error status while it is transmitting
the request.  If the client sees an error status, it SHOULD
immediately cease transmitting the body.  If the body is being sent
using a "chunked" encoding (Section\03.6), a zero length chunk and
empty trailer MAY be used to prematurely mark the end of the message.
If the body was preceded by a \%Content-Length header, the client MUST
close the connection.
.bp
.in 8
.ti 0
8.2.3.  Use of the 100 (Continue) Status
.in 3

The purpose of the 100 (Continue) status (see Section\010.1.1) is to
allow a client that is sending a request message with a request body
to determine if the origin server is willing to accept the request
(based on the request headers) before the client sends the request
body.  In some cases, it might either be inappropriate or highly
inefficient for the client to send the body if the server will reject
the message without looking at the body.

Requirements for HTTP/1.1 clients:

.in 6
.ti 3
o  If a client will wait for a 100 (Continue) response before sending
the request body, it MUST send an Expect \%request-header field
(Section\014.20) with the \%"100-continue" expectation.

.ti 3
o  A client MUST NOT send an Expect \%request-header field
(Section\014.20) with the \%"100-continue" expectation if it does not
intend to send a request body.

.in 3
Because of the presence of older implementations, the protocol allows
ambiguous situations in which a client may send "Expect: \%100-
continue" without receiving either a 417 (Expectation Failed) status
or a 100 (Continue) status.  Therefore, when a client sends this
header field to an origin server (possibly via a proxy) from which it
has never seen a 100 (Continue) status, the client SHOULD NOT wait
for an indefinite period before sending the request body.

Requirements for HTTP/1.1 origin servers:

.in 6
.ti 3
o  Upon receiving a request which includes an Expect \%request-header
field with the \%"100-continue" expectation, an origin server MUST
either respond with 100 (Continue) status and continue to read
from the input stream, or respond with a final status code.  The
origin server MUST NOT wait for the request body before sending
the 100 (Continue) response.  If it responds with a final status
code, it MAY close the transport connection or it MAY continue to
read and discard the rest of the request.  It MUST NOT perform the
requested method if it returns a final status code.

.ti 3
o  An origin server SHOULD NOT send a 100 (Continue) response if the
request message does not include an Expect \%request-header field
with the \%"100-continue" expectation, and MUST NOT send a 100
(Continue) response if such a request comes from an HTTP/1.0 (or
earlier) client.  There is an exception to this rule: for
compatibility with RFC 2068, a server MAY send a 100 (Continue)
status in response to an HTTP/1.1 PUT or POST request that does
not include an Expect \%request-header field with the \%"100-continue"
.bp
expectation.  This exception, the purpose of which is to minimize
any client processing delays associated with an undeclared wait
for 100 (Continue) status, applies only to HTTP/1.1 requests, and
not to requests with any other \%HTTP-version value.

.ti 3
o  An origin server MAY omit a 100 (Continue) response if it has
already received some or all of the request body for the
corresponding request.

.ti 3
o  An origin server that sends a 100 (Continue) response MUST
ultimately send a final status code, once the request body is
received and processed, unless it terminates the transport
connection prematurely.

.ti 3
o  If an origin server receives a request that does not include an
Expect \%request-header field with the \%"100-continue" expectation,
the request includes a request body, and the server responds with
a final status code before reading the entire request body from
the transport connection, then the server SHOULD NOT close the
transport connection until it has read the entire request, or
until the client closes the connection.  Otherwise, the client
might not reliably receive the response message.  However, this
requirement is not be construed as preventing a server from
defending itself against \%denial-of-service attacks, or from badly
broken client implementations.

.in 3
Requirements for HTTP/1.1 proxies:

.in 6
.ti 3
o  If a proxy receives a request that includes an Expect \%request-
header field with the \%"100-continue" expectation, and the proxy
either knows that the \%next-hop server complies with HTTP/1.1 or
higher, or does not know the HTTP version of the \%next-hop server,
it MUST forward the request, including the Expect header field.

.ti 3
o  If the proxy knows that the version of the \%next-hop server is
HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST
respond with a 417 (Expectation Failed) status.

.ti 3
o  Proxies SHOULD maintain a cache recording the HTTP version numbers
received from \%recently-referenced \%next-hop servers.

.ti 3
o  A proxy MUST NOT forward a 100 (Continue) response if the request
message was received from an HTTP/1.0 (or earlier) client and did
not include an Expect \%request-header field with the \%"100-continue"
expectation.  This requirement overrides the general rule for
forwarding of 1xx responses (see Section\010.1).

.in 3
.bp
.in 8
.ti 0
8.2.4.  Client Behavior if Server Prematurely Closes Connection
.in 3

If an HTTP/1.1 client sends a request which includes a request body,
but which does not include an Expect \%request-header field with the
\%"100-continue" expectation, and if the client is not directly
connected to an HTTP/1.1 origin server, and if the client sees the
connection close before receiving any status from the server, the
client SHOULD retry the request.  If the client does retry this
request, it MAY use the following "binary exponential backoff"
algorithm to be assured of obtaining a reliable response:

.in 7
.ti 3
1.  Initiate a new connection to the server

.ti 3
2.  Transmit the \%request-headers

.ti 3
3.  Initialize a variable R to the estimated \%round-trip time to the
server (e.g., based on the time it took to establish the
connection), or to a constant value of 5 seconds if the \%round-
trip time is not available.

.ti 3
4.  Compute T = R * (2**N), where N is the number of previous retries
of this request.

.ti 3
5.  Wait either for an error response from the server, or for T
seconds (whichever comes first)

.ti 3
6.  If no error response is received, after T seconds transmit the
body of the request.

.ti 3
7.  If client sees that the connection is closed prematurely, repeat
from step 1 until the request is accepted, an error response is
received, or the user becomes impatient and terminates the retry
process.

.in 3
If at any point an error status is received, the client

.in 6
.ti 3
o  SHOULD NOT continue and

.ti 3
o  SHOULD close the connection if it has not completed sending the
request message.

.in 3
.bp
.in 4
.ti 0
9.  Method Definitions
.in 3

The set of common methods for HTTP/1.1 is defined below.  Although
this set can be expanded, additional methods cannot be assumed to
share the same semantics for separately extended clients and servers.

The Host \%request-header field (Section\014.23) MUST accompany all
HTTP/1.1 requests.

.in 6
.ti 0
9.1.  Safe and Idempotent Methods
.in 3

.in 8
.ti 0
9.1.1.  Safe Methods
.in 3

Implementors should be aware that the software represents the user in
their interactions over the Internet, and should be careful to allow
the user to be aware of any actions they might take which may have an
unexpected significance to themselves or others.

In particular, the convention has been established that the GET and
HEAD methods SHOULD NOT have the significance of taking an action
other than retrieval.  These methods ought to be considered "safe".
This allows user agents to represent other methods, such as POST, PUT
and DELETE, in a special way, so that the user is made aware of the
fact that a possibly unsafe action is being requested.

Naturally, it is not possible to ensure that the server does not
generate \%side-effects as a result of performing a GET request; in
fact, some dynamic resources consider that a feature.  The important
distinction here is that the user did not request the \%side-effects,
so therefore cannot be held accountable for them.

.in 8
.ti 0
9.1.2.  Idempotent Methods
.in 3

Methods can also have the property of "idempotence" in that (aside
from error or expiration issues) the \%side-effects of N > 0 identical
requests is the same as for a single request.  The methods GET, HEAD,
PUT and DELETE share this property.  Also, the methods OPTIONS and
TRACE SHOULD NOT have side effects, and so are inherently idempotent.

However, it is possible that a sequence of several requests is \%non-
idempotent, even if all of the methods executed in that sequence are
idempotent.  (A sequence is idempotent if a single execution of the
entire sequence always yields a result that is not changed by a
reexecution of all, or part, of that sequence.)  For example, a
sequence is \%non-idempotent if its result depends on a value that is
later modified in the same sequence.

A sequence that never has side effects is idempotent, by definition
.bp
(provided that no concurrent operations are being executed on the
same set of resources).

.in 6
.ti 0
9.2.  OPTIONS
.in 3

The OPTIONS method represents a request for information about the
communication options available on the request/response chain
identified by the \%Request-URI.  This method allows the client to
determine the options and/or requirements associated with a resource,
or the capabilities of a server, without implying a resource action
or initiating a resource retrieval.

Responses to this method are not cacheable.

If the OPTIONS request includes an \%entity-body (as indicated by the
presence of \%Content-Length or \%Transfer-Encoding), then the media type
MUST be indicated by a \%Content-Type field.  Although this
specification does not define any use for such a body, future
extensions to HTTP might use the OPTIONS body to make more detailed
queries on the server.  A server that does not support such an
extension MAY discard the request body.

If the \%Request-URI is an asterisk ("*"), the OPTIONS request is
intended to apply to the server in general rather than to a specific
resource.  Since a server\'s communication options typically depend on
the resource, the "*" request is only useful as a "ping" or \%"no-op"
type of method; it does nothing beyond allowing the client to test
the capabilities of the server.  For example, this can be used to
test a proxy for HTTP/1.1 compliance (or lack thereof).

If the \%Request-URI is not an asterisk, the OPTIONS request applies
only to the options that are available when communicating with that
resource.

A 200 response SHOULD include any header fields that indicate
optional features implemented by the server and applicable to that
resource (e.g., Allow), possibly including extensions not defined by
this specification.  The response body, if any, SHOULD also include
information about the communication options.  The format for such a
body is not defined by this specification, but might be defined by
future extensions to HTTP.  Content negotiation MAY be used to select
the appropriate response format.  If no response body is included,
the response MUST include a \%Content-Length field with a \%field-value
of "0".

The \%Max-Forwards \%request-header field MAY be used to target a
specific proxy in the request chain.  When a proxy receives an
OPTIONS request on an absoluteURI for which request forwarding is
.bp
permitted, the proxy MUST check for a \%Max-Forwards field.  If the
\%Max-Forwards \%field-value is zero ("0"), the proxy MUST NOT forward
the message; instead, the proxy SHOULD respond with its own
communication options.  If the \%Max-Forwards \%field-value is an integer
greater than zero, the proxy MUST decrement the \%field-value when it
forwards the request.  If no \%Max-Forwards field is present in the
request, then the forwarded request MUST NOT include a \%Max-Forwards
field.

.in 6
.ti 0
9.3.  GET
.in 3

The GET method means retrieve whatever information (in the form of an
entity) is identified by the \%Request-URI.  If the \%Request-URI refers
to a \%data-producing process, it is the produced data which shall be
returned as the entity in the response and not the source text of the
process, unless that text happens to be the output of the process.

The semantics of the GET method change to a "conditional GET" if the
request message includes an \%If-Modified-Since, \%If-Unmodified-Since,
\%If-Match, \%If-None-Match, or \%If-Range header field.  A conditional GET
method requests that the entity be transferred only under the
circumstances described by the conditional header field(s).  The
conditional GET method is intended to reduce unnecessary network
usage by allowing cached entities to be refreshed without requiring
multiple requests or transferring data already held by the client.

The semantics of the GET method change to a "partial GET" if the
request message includes a Range header field.  A partial GET
requests that only part of the entity be transferred, as described in
Section\014.35.  The partial GET method is intended to reduce
unnecessary network usage by allowing \%partially-retrieved entities to
be completed without transferring data already held by the client.

The response to a GET request is cacheable if and only if it meets
the requirements for HTTP caching described in Section\013.

See Section\015.1.3 for security considerations when used for forms.

.in 6
.ti 0
9.4.  HEAD
.in 3

The HEAD method is identical to GET except that the server MUST NOT
return a \%message-body in the response.  The metainformation contained
in the HTTP headers in response to a HEAD request SHOULD be identical
to the information sent in response to a GET request.  This method
can be used for obtaining metainformation about the entity implied by
the request without transferring the \%entity-body itself.  This method
is often used for testing hypertext links for validity,
accessibility, and recent modification.
.bp
The response to a HEAD request MAY be cacheable in the sense that the
information contained in the response MAY be used to update a
previously cached entity from that resource.  If the new field values
indicate that the cached entity differs from the current entity (as
would be indicated by a change in \%Content-Length, \%Content-MD5, ETag
or \%Last-Modified), then the cache MUST treat the cache entry as
stale.

.in 6
.ti 0
9.5.  POST
.in 3

The POST method is used to request that the origin server accept the
entity enclosed in the request as a new subordinate of the resource
identified by the \%Request-URI in the \%Request-Line.  POST is designed
to allow a uniform method to cover the following functions:

.in 6
.ti 3
o  Annotation of existing resources;

.ti 3
o  Posting a message to a bulletin board, newsgroup, mailing list, or
similar group of articles;

.ti 3
o  Providing a block of data, such as the result of submitting a
form, to a \%data-handling process;

.ti 3
o  Extending a database through an append operation.

.in 3
The actual function performed by the POST method is determined by the
server and is usually dependent on the \%Request-URI.  The posted
entity is subordinate to that URI in the same way that a file is
subordinate to a directory containing it, a news article is
subordinate to a newsgroup to which it is posted, or a record is
subordinate to a database.

The action performed by the POST method might not result in a
resource that can be identified by a URI.  In this case, either 200
(OK) or 204 (No Content) is the appropriate response status,
depending on whether or not the response includes an entity that
describes the result.

If a resource has been created on the origin server, the response
SHOULD be 201 (Created) and contain an entity which describes the
status of the request and refers to the new resource, and a Location
header (see Section\014.30).

Responses to this method are not cacheable, unless the response
includes appropriate \%Cache-Control or Expires header fields.
However, the 303 (See Other) response can be used to direct the user
agent to retrieve a cacheable resource.

.bp
POST requests MUST obey the message transmission requirements set out
in Section\08.2.

See Section\015.1.3 for security considerations.

.in 6
.ti 0
9.6.  PUT
.in 3

The PUT method requests that the enclosed entity be stored under the
supplied \%Request-URI.  If the \%Request-URI refers to an already
existing resource, the enclosed entity SHOULD be considered as a
modified version of the one residing on the origin server.  If the
\%Request-URI does not point to an existing resource, and that URI is
capable of being defined as a new resource by the requesting user
agent, the origin server can create the resource with that URI.  If a
new resource is created, the origin server MUST inform the user agent
via the 201 (Created) response.  If an existing resource is modified,
either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
to indicate successful completion of the request.  If the resource
could not be created or modified with the \%Request-URI, an appropriate
error response SHOULD be given that reflects the nature of the
problem.  The recipient of the entity MUST NOT ignore any \%Content-*
(e.g.  \%Content-Range) headers that it does not understand or
implement and MUST return a 501 (Not Implemented) response in such
cases.

If the request passes through a cache and the \%Request-URI identifies
one or more currently cached entities, those entries SHOULD be
treated as stale.  Responses to this method are not cacheable.

The fundamental difference between the POST and PUT requests is
reflected in the different meaning of the \%Request-URI.  The URI in a
POST request identifies the resource that will handle the enclosed
entity.  That resource might be a \%data-accepting process, a gateway
to some other protocol, or a separate entity that accepts
annotations.  In contrast, the URI in a PUT request identifies the
entity enclosed with the request \%-- the user agent knows what URI is
intended and the server MUST NOT attempt to apply the request to some
other resource.  If the server desires that the request be applied to
a different URI, it MUST send a 301 (Moved Permanently) response; the
user agent MAY then make its own decision regarding whether or not to
redirect the request.

A single resource MAY be identified by many different URIs.  For
example, an article might have a URI for identifying "the current
version" which is separate from the URI identifying each particular
version.  In this case, a PUT request on a general URI might result
in several other URIs being defined by the origin server.

.bp
HTTP/1.1 does not define how a PUT method affects the state of an
origin server.

PUT requests MUST obey the message transmission requirements set out
in Section\08.2.

Unless otherwise specified for a particular \%entity-header, the
\%entity-headers in the PUT request SHOULD be applied to the resource
created or modified by the PUT.

.in 6
.ti 0
9.7.  DELETE
.in 3

The DELETE method requests that the origin server delete the resource
identified by the \%Request-URI.  This method MAY be overridden by
human intervention (or other means) on the origin server.  The client
cannot be guaranteed that the operation has been carried out, even if
the status code returned from the origin server indicates that the
action has been completed successfully.  However, the server SHOULD
NOT indicate success unless, at the time the response is given, it
intends to delete the resource or move it to an inaccessible
location.

A successful response SHOULD be 200 (OK) if the response includes an
entity describing the status, 202 (Accepted) if the action has not
yet been enacted, or 204 (No Content) if the action has been enacted
but the response does not include an entity.

If the request passes through a cache and the \%Request-URI identifies
one or more currently cached entities, those entries SHOULD be
treated as stale.  Responses to this method are not cacheable.

.in 6
.ti 0
9.8.  TRACE
.in 3

The TRACE method is used to invoke a remote, \%application-layer \%loop-
back of the request message.  The final recipient of the request
SHOULD reflect the message received back to the client as the \%entity-
body of a 200 (OK) response.  The final recipient is either the
origin server or the first proxy or gateway to receive a \%Max-Forwards
value of zero (0) in the request (see Section\014.31).  A TRACE
request MUST NOT include an entity.

TRACE allows the client to see what is being received at the other
end of the request chain and use that data for testing or diagnostic
information.  The value of the Via header field (Section\014.45) is of
particular interest, since it acts as a trace of the request chain.
Use of the \%Max-Forwards header field allows the client to limit the
length of the request chain, which is useful for testing a chain of
proxies forwarding messages in an infinite loop.
.bp
If the request is valid, the response SHOULD contain the entire
request message in the \%entity-body, with a \%Content-Type of "message/
http".  Responses to this method MUST NOT be cached.

.in 6
.ti 0
9.9.  CONNECT
.in 3

This specification reserves the method name CONNECT for use with a
proxy that can dynamically switch to being a tunnel (e.g.  SSL
tunneling [44]).
.bp
.in 5
.ti 0
10.  Status Code Definitions
.in 3

Each \%Status-Code is described below, including a description of which
method(s) it can follow and any metainformation required in the
response.

.in 7
.ti 0
10.1.  Informational 1xx
.in 3

This class of status code indicates a provisional response,
consisting only of the \%Status-Line and optional headers, and is
terminated by an empty line.  There are no required headers for this
class of status code.  Since HTTP/1.0 did not define any 1xx status
codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client
except under experimental conditions.

A client MUST be prepared to accept one or more 1xx status responses
prior to a regular response, even if the client does not expect a 100
(Continue) status message.  Unexpected 1xx status responses MAY be
ignored by a user agent.

Proxies MUST forward 1xx responses, unless the connection between the
proxy and its client has been closed, or unless the proxy itself
requested the generation of the 1xx response.  (For example, if a
proxy adds a "Expect: \%100-continue" field when it forwards a request,
then it need not forward the corresponding 100 (Continue)
response(s).)

.in 9
.ti 0
10.1.1.  100 Continue
.in 3

The client SHOULD continue with its request.  This interim response
is used to inform the client that the initial part of the request has
been received and has not yet been rejected by the server.  The
client SHOULD continue by sending the remainder of the request or, if
the request has already been completed, ignore this response.  The
server MUST send a final response after the request has been
completed.  See Section\08.2.3 for detailed discussion of the use and
handling of this status code.

.in 9
.ti 0
10.1.2.  101 Switching Protocols
.in 3

The server understands and is willing to comply with the client\'s
request, via the Upgrade message header field (Section\014.42), for a
change in the application protocol being used on this connection.
The server will switch protocols to those defined by the response\'s
Upgrade header field immediately after the empty line which
terminates the 101 response.

The protocol SHOULD be switched only when it is advantageous to do
.bp
so.  For example, switching to a newer version of HTTP is
advantageous over older versions, and switching to a \%real-time,
synchronous protocol might be advantageous when delivering resources
that use such features.

.in 7
.ti 0
10.2.  Successful 2xx
.in 3

This class of status code indicates that the client\'s request was
successfully received, understood, and accepted.

.in 9
.ti 0
10.2.1.  200 OK
.in 3

The request has succeeded.  The information returned with the
response is dependent on the method used in the request, for example:

.in 6
.ti 3
GET\0 an entity corresponding to the requested resource is sent in the
response;

.ti 3
HEAD\0 the \%entity-header fields corresponding to the requested
resource are sent in the response without any \%message-body;

.ti 3
POST\0 an entity describing or containing the result of the action;

.ti 3
TRACE\0 an entity containing the request message as received by the
end server.

.in 3
.in 9
.ti 0
10.2.2.  201 Created
.in 3

The request has been fulfilled and resulted in a new resource being
created.  The newly created resource can be referenced by the URI(s)
returned in the entity of the response, with the most specific URI
for the resource given by a Location header field.  The response
SHOULD include an entity containing a list of resource
characteristics and location(s) from which the user or user agent can
choose the one most appropriate.  The entity format is specified by
the media type given in the \%Content-Type header field.  The origin
server MUST create the resource before returning the 201 status code.
If the action cannot be carried out immediately, the server SHOULD
respond with 202 (Accepted) response instead.

A 201 response MAY contain an ETag response header field indicating
the current value of the entity tag for the requested variant just
created, see Section\014.19.

.in 9
.ti 0
10.2.3.  202 Accepted
.in 3

The request has been accepted for processing, but the processing has
not been completed.  The request might or might not eventually be
.bp
acted upon, as it might be disallowed when processing actually takes
place.  There is no facility for \%re-sending a status code from an
asynchronous operation such as this.

The 202 response is intentionally \%non-committal.  Its purpose is to
allow a server to accept a request for some other process (perhaps a
\%batch-oriented process that is only run once per day) without
requiring that the user agent\'s connection to the server persist
until the process is completed.  The entity returned with this
response SHOULD include an indication of the request\'s current status
and either a pointer to a status monitor or some estimate of when the
user can expect the request to be fulfilled.

.in 9
.ti 0
10.2.4.  203 \%Non-Authoritative Information
.in 3

The returned metainformation in the \%entity-header is not the
definitive set as available from the origin server, but is gathered
from a local or a \%third-party copy.  The set presented MAY be a
subset or superset of the original version.  For example, including
local annotation information about the resource might result in a
superset of the metainformation known by the origin server.  Use of
this response code is not required and is only appropriate when the
response would otherwise be 200 (OK).

.in 9
.ti 0
10.2.5.  204 No Content
.in 3

The server has fulfilled the request but does not need to return an
\%entity-body, and might want to return updated metainformation.  The
response MAY include new or updated metainformation in the form of
\%entity-headers, which if present SHOULD be associated with the
requested variant.

If the client is a user agent, it SHOULD NOT change its document view
from that which caused the request to be sent.  This response is
primarily intended to allow input for actions to take place without
causing a change to the user agent\'s active document view, although
any new or updated metainformation SHOULD be applied to the document
currently in the user agent\'s active view.

The 204 response MUST NOT include a \%message-body, and thus is always
terminated by the first empty line after the header fields.

.in 9
.ti 0
10.2.6.  205 Reset Content
.in 3

The server has fulfilled the request and the user agent SHOULD reset
the document view which caused the request to be sent.  This response
is primarily intended to allow input for actions to take place via
user input, followed by a clearing of the form in which the input is
.bp
given so that the user can easily initiate another input action.  The
response MUST NOT include an entity.

.in 9
.ti 0
10.2.7.  206 Partial Content
.in 3

The server has fulfilled the partial GET request for the resource.
The request MUST have included a Range header field (Section\014.35)
indicating the desired range, and MAY have included an \%If-Range
header field (Section\014.27) to make the request conditional.

The response MUST include the following header fields:

.in 6
.ti 3
o  Either a \%Content-Range header field (Section\014.16) indicating the
range included with this response, or a multipart/byteranges
\%Content-Type including \%Content-Range fields for each part.  If a
\%Content-Length header field is present in the response, its value
MUST match the actual number of OCTETs transmitted in the \%message-
body.

.ti 3
o  Date

.ti 3
o  ETag and/or \%Content-Location, if the header would have been sent
in a 200 response to the same request

.ti 3
o  Expires, \%Cache-Control, and/or Vary, if the \%field-value might
differ from that sent in any previous response for the same
variant

.in 3
If the 206 response is the result of an \%If-Range request that used a
strong cache validator (see Section\013.3.3), the response SHOULD NOT
include other \%entity-headers.  If the response is the result of an
\%If-Range request that used a weak validator, the response MUST NOT
include other \%entity-headers; this prevents inconsistencies between
cached \%entity-bodies and updated headers.  Otherwise, the response
MUST include all of the \%entity-headers that would have been returned
with a 200 (OK) response to the same request.

A cache MUST NOT combine a 206 response with other previously cached
content if the ETag or \%Last-Modified headers do not match exactly,
see 13.5.4.

A cache that does not support the Range and \%Content-Range headers
MUST NOT cache 206 (Partial) responses.

.in 7
.ti 0
10.3.  Redirection 3xx
.in 3

This class of status code indicates that further action needs to be
taken by the user agent in order to fulfill the request.  The action
.bp
required MAY be carried out by the user agent without interaction
with the user if and only if the method used in the second request is
GET or HEAD.  A client SHOULD detect infinite redirection loops,
since such loops generate network traffic for each redirection.

.in 6
.ti 6
Note: previous versions of this specification recommended a
maximum of five redirections.  Content developers should be aware
that there might be clients that implement such a fixed
limitation.

.in 3
.in 9
.ti 0
10.3.1.  300 Multiple Choices
.in 3

The requested resource corresponds to any one of a set of
representations, each with its own specific location, and \%agent-
driven negotiation information (Section\012) is being provided so that
the user (or user agent) can select a preferred representation and
redirect its request to that location.

Unless it was a HEAD request, the response SHOULD include an entity
containing a list of resource characteristics and location(s) from
which the user or user agent can choose the one most appropriate.
The entity format is specified by the media type given in the
\%Content-Type header field.  Depending upon the format and the
capabilities of the user agent, selection of the most appropriate
choice MAY be performed automatically.  However, this specification
does not define any standard for such automatic selection.

If the server has a preferred choice of representation, it SHOULD
include the specific URI for that representation in the Location
field; user agents MAY use the Location field value for automatic
redirection.  This response is cacheable unless indicated otherwise.

.in 9
.ti 0
10.3.2.  301 Moved Permanently
.in 3

The requested resource has been assigned a new permanent URI and any
future references to this resource SHOULD use one of the returned
URIs.  Clients with link editing capabilities ought to automatically
\%re-link references to the \%Request-URI to one or more of the new
references returned by the server, where possible.  This response is
cacheable unless indicated otherwise.

The new permanent URI SHOULD be given by the Location field in the
response.  Unless the request method was HEAD, the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URI(s).

If the 301 status code is received in response to a request other
than GET or HEAD, the user agent MUST NOT automatically redirect the
.bp
request unless it can be confirmed by the user, since this might
change the conditions under which the request was issued.

.in 6
.ti 6
Note: When automatically redirecting a POST request after
receiving a 301 status code, some existing HTTP/1.0 user agents
will erroneously change it into a GET request.

.in 3
.in 9
.ti 0
10.3.3.  302 Found
.in 3

The requested resource resides temporarily under a different URI.
Since the redirection might be altered on occasion, the client SHOULD
continue to use the \%Request-URI for future requests.  This response
is only cacheable if indicated by a \%Cache-Control or Expires header
field.

The temporary URI SHOULD be given by the Location field in the
response.  Unless the request method was HEAD, the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URI(s).

If the 302 status code is received in response to a request other
than GET or HEAD, the user agent MUST NOT automatically redirect the
request unless it can be confirmed by the user, since this might
change the conditions under which the request was issued.

.in 6
.ti 6
Note: RFC 1945 and RFC 2068 specify that the client is not allowed
to change the method on the redirected request.  However, most
existing user agent implementations treat 302 as if it were a 303
response, performing a GET on the Location \%field-value regardless
of the original request method.  The status codes 303 and 307 have
been added for servers that wish to make unambiguously clear which
kind of reaction is expected of the client.

.in 3
.in 9
.ti 0
10.3.4.  303 See Other
.in 3

The response to the request can be found under a different URI and
SHOULD be retrieved using a GET method on that resource.  This method
exists primarily to allow the output of a \%POST-activated script to
redirect the user agent to a selected resource.  The new URI is not a
substitute reference for the originally requested resource.  The 303
response MUST NOT be cached, but the response to the second
(redirected) request might be cacheable.

The different URI SHOULD be given by the Location field in the
response.  Unless the request method was HEAD, the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URI(s).
.bp
.in 6
.ti 6
Note: Many \%pre-HTTP/1.1 user agents do not understand the 303
status.  When interoperability with such clients is a concern, the
302 status code may be used instead, since most user agents react
to a 302 response as described here for 303.

.in 3
.in 9
.ti 0
10.3.5.  304 Not Modified
.in 3

If the client has performed a conditional GET request and access is
allowed, but the document has not been modified, the server SHOULD
respond with this status code.  The 304 response MUST NOT contain a
\%message-body, and thus is always terminated by the first empty line
after the header fields.

The response MUST include the following header fields:

.in 6
.ti 3
o  Date, unless its omission is required by Section\014.18.1

.in 3
If a clockless origin server obeys these rules, and proxies and
clients add their own Date to any response received without one (as
already specified by [RFC 2068], section 14.19), caches will operate
correctly.

.in 6
.ti 3
o  ETag and/or \%Content-Location, if the header would have been sent
in a 200 response to the same request

.ti 3
o  Expires, \%Cache-Control, and/or Vary, if the \%field-value might
differ from that sent in any previous response for the same
variant

.in 3
If the conditional GET used a strong cache validator (see
Section\013.3.3), the response SHOULD NOT include other \%entity-
headers.  Otherwise (i.e., the conditional GET used a weak
validator), the response MUST NOT include other \%entity-headers; this
prevents inconsistencies between cached \%entity-bodies and updated
headers.

If a 304 response indicates an entity not currently cached, then the
cache MUST disregard the response and repeat the request without the
conditional.

If a cache uses a received 304 response to update a cache entry, the
cache MUST update the entry to reflect any new field values given in
the response.

.in 9
.ti 0
10.3.6.  305 Use Proxy
.in 3

The requested resource MUST be accessed through the proxy given by
the Location field.  The Location field gives the URI of the proxy.
.bp
The recipient is expected to repeat this single request via the
proxy. 305 responses MUST only be generated by origin servers.

.in 6
.ti 6
Note: RFC 2068 was not clear that 305 was intended to redirect a
single request, and to be generated by origin servers only.  Not
observing these limitations has significant security consequences.

.in 3
.in 9
.ti 0
10.3.7.  306 (Unused)
.in 3

The 306 status code was used in a previous version of the
specification, is no longer used, and the code is reserved.

.in 9
.ti 0
10.3.8.  307 Temporary Redirect
.in 3

The requested resource resides temporarily under a different URI.
Since the redirection MAY be altered on occasion, the client SHOULD
continue to use the \%Request-URI for future requests.  This response
is only cacheable if indicated by a \%Cache-Control or Expires header
field.

The temporary URI SHOULD be given by the Location field in the
response.  Unless the request method was HEAD, the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URI(s) , since many \%pre-HTTP/1.1 user agents do not
understand the 307 status.  Therefore, the note SHOULD contain the
information necessary for a user to repeat the original request on
the new URI.

If the 307 status code is received in response to a request other
than GET or HEAD, the user agent MUST NOT automatically redirect the
request unless it can be confirmed by the user, since this might
change the conditions under which the request was issued.

.in 7
.ti 0
10.4.  Client Error 4xx
.in 3

The 4xx class of status code is intended for cases in which the
client seems to have erred.  Except when responding to a HEAD
request, the server SHOULD include an entity containing an
explanation of the error situation, and whether it is a temporary or
permanent condition.  These status codes are applicable to any
request method.  User agents SHOULD display any included entity to
the user.

If the client is sending data, a server implementation using TCP
SHOULD be careful to ensure that the client acknowledges receipt of
the packet(s) containing the response, before the server closes the
input connection.  If the client continues sending data to the server
after the close, the server\'s TCP stack will send a reset packet to
.bp
the client, which may erase the client\'s unacknowledged input buffers
before they can be read and interpreted by the HTTP application.

.in 9
.ti 0
10.4.1.  400 Bad Request
.in 3

The request could not be understood by the server due to malformed
syntax.  The client SHOULD NOT repeat the request without
modifications.

.in 9
.ti 0
10.4.2.  401 Unauthorized
.in 3

The request requires user authentication.  The response MUST include
a \%WWW-Authenticate header field (Section\014.47) containing a
challenge applicable to the requested resource.  The client MAY
repeat the request with a suitable Authorization header field
(Section\014.8).  If the request already included Authorization
credentials, then the 401 response indicates that authorization has
been refused for those credentials.  If the 401 response contains the
same challenge as the prior response, and the user agent has already
attempted authentication at least once, then the user SHOULD be
presented the entity that was given in the response, since that
entity might include relevant diagnostic information.  HTTP access
authentication is explained in "HTTP Authentication: Basic and Digest
Access Authentication" [43].

.in 9
.ti 0
10.4.3.  402 Payment Required
.in 3

This code is reserved for future use.

.in 9
.ti 0
10.4.4.  403 Forbidden
.in 3

The server understood the request, but is refusing to fulfill it.
Authorization will not help and the request SHOULD NOT be repeated.
If the request method was not HEAD and the server wishes to make
public why the request has not been fulfilled, it SHOULD describe the
reason for the refusal in the entity.  If the server does not wish to
make this information available to the client, the status code 404
(Not Found) can be used instead.

.in 9
.ti 0
10.4.5.  404 Not Found
.in 3

The server has not found anything matching the \%Request-URI.  No
indication is given of whether the condition is temporary or
permanent.  The 410 (Gone) status code SHOULD be used if the server
knows, through some internally configurable mechanism, that an old
resource is permanently unavailable and has no forwarding address.
This status code is commonly used when the server does not wish to
reveal exactly why the request has been refused, or when no other
.bp
response is applicable.

.in 9
.ti 0
10.4.6.  405 Method Not Allowed
.in 3

The method specified in the \%Request-Line is not allowed for the
resource identified by the \%Request-URI.  The response MUST include an
Allow header containing a list of valid methods for the requested
resource.

.in 9
.ti 0
10.4.7.  406 Not Acceptable
.in 3

The resource identified by the request is only capable of generating
response entities which have content characteristics not acceptable
according to the accept headers sent in the request.

Unless it was a HEAD request, the response SHOULD include an entity
containing a list of available entity characteristics and location(s)
from which the user or user agent can choose the one most
appropriate.  The entity format is specified by the media type given
in the \%Content-Type header field.  Depending upon the format and the
capabilities of the user agent, selection of the most appropriate
choice MAY be performed automatically.  However, this specification
does not define any standard for such automatic selection.

.in 6
.ti 6
Note: HTTP/1.1 servers are allowed to return responses which are
not acceptable according to the accept headers sent in the
request.  In some cases, this may even be preferable to sending a
406 response.  User agents are encouraged to inspect the headers
of an incoming response to determine if it is acceptable.

.in 3
If the response could be unacceptable, a user agent SHOULD
temporarily stop receipt of more data and query the user for a
decision on further actions.

.in 9
.ti 0
10.4.8.  407 Proxy Authentication Required
.in 3

This code is similar to 401 (Unauthorized), but indicates that the
client must first authenticate itself with the proxy.  The proxy MUST
return a \%Proxy-Authenticate header field (Section\014.33) containing a
challenge applicable to the proxy for the requested resource.  The
client MAY repeat the request with a suitable \%Proxy-Authorization
header field (Section\014.34).  HTTP access authentication is
explained in "HTTP Authentication: Basic and Digest Access
Authentication" [43].
.bp
.in 9
.ti 0
10.4.9.  408 Request Timeout
.in 3

The client did not produce a request within the time that the server
was prepared to wait.  The client MAY repeat the request without
modifications at any later time.

.in 10
.ti 0
10.4.10.  409 Conflict
.in 3

The request could not be completed due to a conflict with the current
state of the resource.  This code is only allowed in situations where
it is expected that the user might be able to resolve the conflict
and resubmit the request.  The response body SHOULD include enough
information for the user to recognize the source of the conflict.
Ideally, the response entity would include enough information for the
user or user agent to fix the problem; however, that might not be
possible and is not required.

Conflicts are most likely to occur in response to a PUT request.  For
example, if versioning were being used and the entity being PUT
included changes to a resource which conflict with those made by an
earlier \%(third-party) request, the server might use the 409 response
to indicate that it can\'t complete the request.  In this case, the
response entity would likely contain a list of the differences
between the two versions in a format defined by the response \%Content-
Type.

.in 10
.ti 0
10.4.11.  410 Gone
.in 3

The requested resource is no longer available at the server and no
forwarding address is known.  This condition is expected to be
considered permanent.  Clients with link editing capabilities SHOULD
delete references to the \%Request-URI after user approval.  If the
server does not know, or has no facility to determine, whether or not
the condition is permanent, the status code 404 (Not Found) SHOULD be
used instead.  This response is cacheable unless indicated otherwise.

The 410 response is primarily intended to assist the task of web
maintenance by notifying the recipient that the resource is
intentionally unavailable and that the server owners desire that
remote links to that resource be removed.  Such an event is common
for \%limited-time, promotional services and for resources belonging to
individuals no longer working at the server\'s site.  It is not
necessary to mark all permanently unavailable resources as "gone" or
to keep the mark for any length of time \%-- that is left to the
discretion of the server owner.
.bp
.in 10
.ti 0
10.4.12.  411 Length Required
.in 3

The server refuses to accept the request without a defined \%Content-
Length.  The client MAY repeat the request if it adds a valid
\%Content-Length header field containing the length of the \%message-body
in the request message.

.in 10
.ti 0
10.4.13.  412 Precondition Failed
.in 3

The precondition given in one or more of the \%request-header fields
evaluated to false when it was tested on the server.  This response
code allows the client to place preconditions on the current resource
metainformation (header field data) and thus prevent the requested
method from being applied to a resource other than the one intended.

.in 10
.ti 0
10.4.14.  413 Request Entity Too Large
.in 3

The server is refusing to process a request because the request
entity is larger than the server is willing or able to process.  The
server MAY close the connection to prevent the client from continuing
the request.

If the condition is temporary, the server SHOULD include a \%Retry-
After header field to indicate that it is temporary and after what
time the client MAY try again.

.in 10
.ti 0
10.4.15.  414 \%Request-URI Too Long
.in 3

The server is refusing to service the request because the \%Request-URI
is longer than the server is willing to interpret.  This rare
condition is only likely to occur when a client has improperly
converted a POST request to a GET request with long query
information, when the client has descended into a URI "black hole" of
redirection (e.g., a redirected URI prefix that points to a suffix of
itself), or when the server is under attack by a client attempting to
exploit security holes present in some servers using \%fixed-length
buffers for reading or manipulating the \%Request-URI.

.in 10
.ti 0
10.4.16.  415 Unsupported Media Type
.in 3

The server is refusing to service the request because the entity of
the request is in a format not supported by the requested resource
for the requested method.

.in 10
.ti 0
10.4.17.  416 Requested Range Not Satisfiable
.in 3

A server SHOULD return a response with this status code if a request
included a Range \%request-header field (Section\014.35), and none of
.bp
the \%range-specifier values in this field overlap the current extent
of the selected resource, and the request did not include an \%If-Range
\%request-header field.  (For \%byte-ranges, this means that the \%first-
\%byte-pos of all of the \%byte-range-spec values were greater than the
current length of the selected resource.)

When this status code is returned for a \%byte-range request, the
response SHOULD include a \%Content-Range \%entity-header field
specifying the current length of the selected resource (see
Section\014.16).  This response MUST NOT use the multipart/byteranges
\%content-type.

.in 10
.ti 0
10.4.18.  417 Expectation Failed
.in 3

The expectation given in an Expect \%request-header field (see
Section\014.20) could not be met by this server, or, if the server is
a proxy, the server has unambiguous evidence that the request could
not be met by the \%next-hop server.

.in 7
.ti 0
10.5.  Server Error 5xx
.in 3

Response status codes beginning with the digit "5" indicate cases in
which the server is aware that it has erred or is incapable of
performing the request.  Except when responding to a HEAD request,
the server SHOULD include an entity containing an explanation of the
error situation, and whether it is a temporary or permanent
condition.  User agents SHOULD display any included entity to the
user.  These response codes are applicable to any request method.

.in 9
.ti 0
10.5.1.  500 Internal Server Error
.in 3

The server encountered an unexpected condition which prevented it
from fulfilling the request.

.in 9
.ti 0
10.5.2.  501 Not Implemented
.in 3

The server does not support the functionality required to fulfill the
request.  This is the appropriate response when the server does not
recognize the request method and is not capable of supporting it for
any resource.

.in 9
.ti 0
10.5.3.  502 Bad Gateway
.in 3

The server, while acting as a gateway or proxy, received an invalid
response from the upstream server it accessed in attempting to
fulfill the request.
.bp
.in 9
.ti 0
10.5.4.  503 Service Unavailable
.in 3

The server is currently unable to handle the request due to a
temporary overloading or maintenance of the server.  The implication
is that this is a temporary condition which will be alleviated after
some delay.  If known, the length of the delay MAY be indicated in a
\%Retry-After header.  If no \%Retry-After is given, the client SHOULD
handle the response as it would for a 500 response.

.in 6
.ti 6
Note: The existence of the 503 status code does not imply that a
server must use it when becoming overloaded.  Some servers may
wish to simply refuse the connection.

.in 3
.in 9
.ti 0
10.5.5.  504 Gateway Timeout
.in 3

The server, while acting as a gateway or proxy, did not receive a
timely response from the upstream server specified by the URI (e.g.
HTTP, FTP, LDAP) or some other auxiliary server (e.g.  DNS) it needed
to access in attempting to complete the request.

.in 6
.ti 6
Note: Note to implementors: some deployed proxies are known to
return 400 or 500 when DNS lookups time out.

.in 3
.in 9
.ti 0
10.5.6.  505 HTTP Version Not Supported
.in 3

The server does not support, or refuses to support, the HTTP protocol
version that was used in the request message.  The server is
indicating that it is unable or unwilling to complete the request
using the same major version as the client, as described in
Section\03.1, other than with this error message.  The response SHOULD
contain an entity describing why that version is not supported and
what other protocols are supported by that server.
.bp
.in 5
.ti 0
11.  Access Authentication
.in 3

HTTP provides several OPTIONAL \%challenge-response authentication
mechanisms which can be used by a server to challenge a client
request and by a client to provide authentication information.  The
general framework for access authentication, and the specification of
"basic" and "digest" authentication, are specified in "HTTP
Authentication: Basic and Digest Access Authentication" [43].  This
specification adopts the definitions of "challenge" and "credentials"
from that specification.
.bp
.in 5
.ti 0
12.  Content Negotiation
.in 3

Most HTTP responses include an entity which contains information for
interpretation by a human user.  Naturally, it is desirable to supply
the user with the "best available" entity corresponding to the
request.  Unfortunately for servers and caches, not all users have
the same preferences for what is "best," and not all user agents are
equally capable of rendering all entity types.  For that reason, HTTP
has provisions for several mechanisms for "content negotiation" \%--
the process of selecting the best representation for a given response
when there are multiple representations available.

.in 6
.ti 6
Note: This is not called "format negotiation" because the
alternate representations may be of the same media type, but use
different capabilities of that type, be in different languages,
etc.

.in 3
Any response containing an \%entity-body MAY be subject to negotiation,
including error responses.

There are two kinds of content negotiation which are possible in
HTTP: \%server-driven and \%agent-driven negotiation.  These two kinds of
negotiation are orthogonal and thus may be used separately or in
combination.  One method of combination, referred to as transparent
negotiation, occurs when a cache uses the \%agent-driven negotiation
information provided by the origin server in order to provide \%server-
driven negotiation for subsequent requests.

.in 7
.ti 0
12.1.  \%Server-driven Negotiation
.in 3

If the selection of the best representation for a response is made by
an algorithm located at the server, it is called \%server-driven
negotiation.  Selection is based on the available representations of
the response (the dimensions over which it can vary; e.g. language,
\%content-coding, etc.) and the contents of particular header fields in
the request message or on other information pertaining to the request
(such as the network address of the client).

\%Server-driven negotiation is advantageous when the algorithm for
selecting from among the available representations is difficult to
describe to the user agent, or when the server desires to send its
"best guess" to the client along with the first response (hoping to
avoid the \%round-trip delay of a subsequent request if the "best
guess" is good enough for the user).  In order to improve the
server\'s guess, the user agent MAY include request header fields
(Accept, \%Accept-Language, \%Accept-Encoding, etc.) which describe its
preferences for such a response.

.bp
\%Server-driven negotiation has disadvantages:

.in 7
.ti 3
1.  It is impossible for the server to accurately determine what
might be "best" for any given user, since that would require
complete knowledge of both the capabilities of the user agent and
the intended use for the response (e.g., does the user want to
view it on screen or print it on paper?).

.ti 3
2.  Having the user agent describe its capabilities in every request
can be both very inefficient (given that only a small percentage
of responses have multiple representations) and a potential
violation of the user\'s privacy.

.ti 3
3.  It complicates the implementation of an origin server and the
algorithms for generating responses to a request.

.ti 3
4.  It may limit a public cache\'s ability to use the same response
for multiple user\'s requests.

.in 3
HTTP/1.1 includes the following \%request-header fields for enabling
\%server-driven negotiation through description of user agent
capabilities and user preferences: Accept (Section\014.1), \%Accept-
Charset (Section\014.2), \%Accept-Encoding (Section\014.3), \%Accept-
Language (Section\014.4), and \%User-Agent (Section\014.43).  However, an
origin server is not limited to these dimensions and MAY vary the
response based on any aspect of the request, including information
outside the \%request-header fields or within extension header fields
not defined by this specification.

The Vary header field can be used to express the parameters the
server uses to select a representation that is subject to \%server-
driven negotiation.  See Section\013.6 for use of the Vary header
field by caches and Section\014.44 for use of the Vary header field by
servers.

.in 7
.ti 0
12.2.  \%Agent-driven Negotiation
.in 3

With \%agent-driven negotiation, selection of the best representation
for a response is performed by the user agent after receiving an
initial response from the origin server.  Selection is based on a
list of the available representations of the response included within
the header fields or \%entity-body of the initial response, with each
representation identified by its own URI.  Selection from among the
representations may be performed automatically (if the user agent is
capable of doing so) or manually by the user selecting from a
generated (possibly hypertext) menu.

\%Agent-driven negotiation is advantageous when the response would vary
.bp
over \%commonly-used dimensions (such as type, language, or encoding),
when the origin server is unable to determine a user agent\'s
capabilities from examining the request, and generally when public
caches are used to distribute server load and reduce network usage.

\%Agent-driven negotiation suffers from the disadvantage of needing a
second request to obtain the best alternate representation.  This
second request is only efficient when caching is used.  In addition,
this specification does not define any mechanism for supporting
automatic selection, though it also does not prevent any such
mechanism from being developed as an extension and used within
HTTP/1.1.

HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)
status codes for enabling \%agent-driven negotiation when the server is
unwilling or unable to provide a varying response using \%server-driven
negotiation.

.in 7
.ti 0
12.3.  Transparent Negotiation
.in 3

Transparent negotiation is a combination of both \%server-driven and
\%agent-driven negotiation.  When a cache is supplied with a form of
the list of available representations of the response (as in \%agent-
driven negotiation) and the dimensions of variance are completely
understood by the cache, then the cache becomes capable of performing
\%server-driven negotiation on behalf of the origin server for
subsequent requests on that resource.

Transparent negotiation has the advantage of distributing the
negotiation work that would otherwise be required of the origin
server and also removing the second request delay of \%agent-driven
negotiation when the cache is able to correctly guess the right
response.

This specification does not define any mechanism for transparent
negotiation, though it also does not prevent any such mechanism from
being developed as an extension that could be used within HTTP/1.1.
.bp
.in 5
.ti 0
13.  Caching in HTTP
.in 3

HTTP is typically used for distributed information systems, where
performance can be improved by the use of response caches.  The
HTTP/1.1 protocol includes a number of elements intended to make
caching work as well as possible.  Because these elements are
inextricable from other aspects of the protocol, and because they
interact with each other, it is useful to describe the basic caching
design of HTTP separately from the detailed descriptions of methods,
headers, response codes, etc.

Caching would be useless if it did not significantly improve
performance.  The goal of caching in HTTP/1.1 is to eliminate the
need to send requests in many cases, and to eliminate the need to
send full responses in many other cases.  The former reduces the
number of network \%round-trips required for many operations; we use an
"expiration" mechanism for this purpose (see Section\013.2).  The
latter reduces network bandwidth requirements; we use a "validation"
mechanism for this purpose (see Section\013.3).

Requirements for performance, availability, and disconnected
operation require us to be able to relax the goal of semantic
transparency.  The HTTP/1.1 protocol allows origin servers, caches,
and clients to explicitly reduce transparency when necessary.
However, because \%non-transparent operation may confuse \%non-expert
users, and might be incompatible with certain server applications
(such as those for ordering merchandise), the protocol requires that
transparency be relaxed

.in 6
.ti 3
o  only by an explicit \%protocol-level request when relaxed by client
or origin server

.ti 3
o  only with an explicit warning to the end user when relaxed by
cache or client

.in 3
Therefore, the HTTP/1.1 protocol provides these important elements:

.in 7
.ti 3
1.  Protocol features that provide full semantic transparency when
this is required by all parties.

.ti 3
2.  Protocol features that allow an origin server or user agent to
explicitly request and control \%non-transparent operation.

.ti 3
3.  Protocol features that allow a cache to attach warnings to
responses that do not preserve the requested approximation of
semantic transparency.

.in 3
A basic principle is that it must be possible for the clients to
.bp
detect any potential relaxation of semantic transparency.

.in 6
.ti 6
Note: The server, cache, or client implementor might be faced with
design decisions not explicitly discussed in this specification.
If a decision might affect semantic transparency, the implementor
ought to err on the side of maintaining transparency unless a
careful and complete analysis shows significant benefits in
breaking transparency.

.in 3
.in 7
.ti 0
13.1.
.in 3

.in 9
.ti 0
13.1.1.  Cache Correctness
.in 3

A correct cache MUST respond to a request with the most \%up-to-date
response held by the cache that is appropriate to the request (see
sections 13.2.5, 13.2.6, and 13.12) which meets one of the following
conditions:

.in 7
.ti 3
1.  It has been checked for equivalence with what the origin server
would have returned by revalidating the response with the origin
server (Section\013.3);

.ti 3
2.  It is "fresh enough" (see Section\013.2).  In the default case,
this means it meets the least restrictive freshness requirement
of the client, origin server, and cache (see Section\014.9); if
the origin server so specifies, it is the freshness requirement
of the origin server alone.  If a stored response is not "fresh
enough" by the most restrictive freshness requirement of both the
client and the origin server, in carefully considered
circumstances the cache MAY still return the response with the
appropriate Warning header (see section 13.1.5 and 14.46), unless
such a response is prohibited (e.g., by a \%"no-store" \%cache-
directive, or by a \%"no-cache" \%cache-request-directive; see
Section\014.9).

.ti 3
3.  It is an appropriate 304 (Not Modified), 305 (Proxy Redirect), or
error (4xx or 5xx) response message.

.in 3
If the cache can not communicate with the origin server, then a
correct cache SHOULD respond as above if the response can be
correctly served from the cache; if not it MUST return an error or
warning indicating that there was a communication failure.

If a cache receives a response (either an entire response, or a 304
(Not Modified) response) that it would normally forward to the
requesting client, and the received response is no longer fresh, the
cache SHOULD forward it to the requesting client without adding a new
Warning (but without removing any existing Warning headers).  A cache
.bp
SHOULD NOT attempt to revalidate a response simply because that
response became stale in transit; this might lead to an infinite
loop.  A user agent that receives a stale response without a Warning
MAY display a warning indication to the user.

.in 9
.ti 0
13.1.2.  Warnings
.in 3

Whenever a cache returns a response that is neither \%first-hand nor
"fresh enough" (in the sense of condition 2 in Section\013.1.1), it
MUST attach a warning to that effect, using a Warning \%general-header.
The Warning header and the currently defined warnings are described
in Section\014.46.  The warning allows clients to take appropriate
action.

Warnings MAY be used for other purposes, both \%cache-related and
otherwise.  The use of a warning, rather than an error status code,
distinguish these responses from true failures.

Warnings are assigned three digit \%warn-codes.  The first digit
indicates whether the Warning MUST or MUST NOT be deleted from a
stored cache entry after a successful revalidation:

.in 6
.ti 3
1xx\0 Warnings that describe the freshness or revalidation status of
the response, and so MUST be deleted after a successful
revalidation. 1XX \%warn-codes MAY be generated by a cache only when
validating a cached entry.  It MUST NOT be generated by clients.

.ti 3
2xx\0 Warnings that describe some aspect of the entity body or entity
headers that is not rectified by a revalidation (for example, a
lossy compression of the entity bodies) and which MUST NOT be
deleted after a successful revalidation.

.in 3
See Section\014.46 for the definitions of the codes themselves.

HTTP/1.0 caches will cache all Warnings in responses, without
deleting the ones in the first category.  Warnings in responses that
are passed to HTTP/1.0 caches carry an extra \%warning-date field,
which prevents a future HTTP/1.1 recipient from believing an
erroneously cached Warning.

Warnings also carry a warning text.  The text MAY be in any
appropriate natural language (perhaps based on the client\'s Accept
headers), and include an OPTIONAL indication of what character set is
used.

Multiple warnings MAY be attached to a response (either by the origin
server or by a cache), including multiple warnings with the same code
number.  For example, a server might provide the same warning with
.bp
texts in both English and Basque.

When multiple warnings are attached to a response, it might not be
practical or reasonable to display all of them to the user.  This
version of HTTP does not specify strict priority rules for deciding
which warnings to display and in what order, but does suggest some
heuristics.

.in 9
.ti 0
13.1.3.  \%Cache-control Mechanisms
.in 3

The basic cache mechanisms in HTTP/1.1 \%(server-specified expiration
times and validators) are implicit directives to caches.  In some
cases, a server or client might need to provide explicit directives
to the HTTP caches.  We use the \%Cache-Control header for this
purpose.

The \%Cache-Control header allows a client or server to transmit a
variety of directives in either requests or responses.  These
directives typically override the default caching algorithms.  As a
general rule, if there is any apparent conflict between header
values, the most restrictive interpretation is applied (that is, the
one that is most likely to preserve semantic transparency).  However,
in some cases, \%cache-control directives are explicitly specified as
weakening the approximation of semantic transparency (for example,
\%"max-stale" or "public").

The \%cache-control directives are described in detail in Section\014.9.

.in 9
.ti 0
13.1.4.  Explicit User Agent Warnings
.in 3

Many user agents make it possible for users to override the basic
caching mechanisms.  For example, the user agent might allow the user
to specify that cached entities (even explicitly stale ones) are
never validated.  Or the user agent might habitually add \%"Cache-
Control: \%max-stale=3600" to every request.  The user agent SHOULD NOT
default to either \%non-transparent behavior, or behavior that results
in abnormally ineffective caching, but MAY be explicitly configured
to do so by an explicit action of the user.

If the user has overridden the basic caching mechanisms, the user
agent SHOULD explicitly indicate to the user whenever this results in
the display of information that might not meet the server\'s
transparency requirements (in particular, if the displayed entity is
known to be stale).  Since the protocol normally allows the user
agent to determine if responses are stale or not, this indication
need only be displayed when this actually happens.  The indication
need not be a dialog box; it could be an icon (for example, a picture
of a rotting fish) or some other indicator.
.bp
If the user has overridden the caching mechanisms in a way that would
abnormally reduce the effectiveness of caches, the user agent SHOULD
continually indicate this state to the user (for example, by a
display of a picture of currency in flames) so that the user does not
inadvertently consume excess resources or suffer from excessive
latency.

.in 9
.ti 0
13.1.5.  Exceptions to the Rules and Warnings
.in 3

In some cases, the operator of a cache MAY choose to configure it to
return stale responses even when not requested by clients.  This
decision ought not be made lightly, but may be necessary for reasons
of availability or performance, especially when the cache is poorly
connected to the origin server.  Whenever a cache returns a stale
response, it MUST mark it as such (using a Warning header) enabling
the client software to alert the user that there might be a potential
problem.

It also allows the user agent to take steps to obtain a \%first-hand or
fresh response.  For this reason, a cache SHOULD NOT return a stale
response if the client explicitly requests a \%first-hand or fresh one,
unless it is impossible to comply for technical or policy reasons.

.in 9
.ti 0
13.1.6.  \%Client-controlled Behavior
.in 3

While the origin server (and to a lesser extent, intermediate caches,
by their contribution to the age of a response) are the primary
source of expiration information, in some cases the client might need
to control a cache\'s decision about whether to return a cached
response without validating it.  Clients do this using several
directives of the \%Cache-Control header.

A client\'s request MAY specify the maximum age it is willing to
accept of an unvalidated response; specifying a value of zero forces
the cache(s) to revalidate all responses.  A client MAY also specify
the minimum time remaining before a response expires.  Both of these
options increase constraints on the behavior of caches, and so cannot
further relax the cache\'s approximation of semantic transparency.

A client MAY also specify that it will accept stale responses, up to
some maximum amount of staleness.  This loosens the constraints on
the caches, and so might violate the origin server\'s specified
constraints on semantic transparency, but might be necessary to
support disconnected operation, or high availability in the face of
poor connectivity.
.bp
.in 7
.ti 0
13.2.  Expiration Model
.in 3

.in 9
.ti 0
13.2.1.  \%Server-Specified Expiration
.in 3

HTTP caching works best when caches can entirely avoid making
requests to the origin server.  The primary mechanism for avoiding
requests is for an origin server to provide an explicit expiration
time in the future, indicating that a response MAY be used to satisfy
subsequent requests.  In other words, a cache can return a fresh
response without first contacting the server.

Our expectation is that servers will assign future explicit
expiration times to responses in the belief that the entity is not
likely to change, in a semantically significant way, before the
expiration time is reached.  This normally preserves semantic
transparency, as long as the server\'s expiration times are carefully
chosen.

The expiration mechanism applies only to responses taken from a cache
and not to \%first-hand responses forwarded immediately to the
requesting client.

If an origin server wishes to force a semantically transparent cache
to validate every request, it MAY assign an explicit expiration time
in the past.  This means that the response is always stale, and so
the cache SHOULD validate it before using it for subsequent requests.
See Section\014.9.4 for a more restrictive way to force revalidation.

If an origin server wishes to force any HTTP/1.1 cache, no matter how
it is configured, to validate every request, it SHOULD use the \%"must-
revalidate" \%cache-control directive (see Section\014.9).

Servers specify explicit expiration times using either the Expires
header, or the \%max-age directive of the \%Cache-Control header.

An expiration time cannot be used to force a user agent to refresh
its display or reload a resource; its semantics apply only to caching
mechanisms, and such mechanisms need only check a resource\'s
expiration status when a new request for that resource is initiated.
See Section\013.13 for an explanation of the difference between caches
and history mechanisms.

.in 9
.ti 0
13.2.2.  Heuristic Expiration
.in 3

Since origin servers do not always provide explicit expiration times,
HTTP caches typically assign heuristic expiration times, employing
algorithms that use other header values (such as the \%Last-Modified
time) to estimate a plausible expiration time.  The HTTP/1.1
.bp
specification does not provide specific algorithms, but does impose
\%worst-case constraints on their results.  Since heuristic expiration
times might compromise semantic transparency, they ought to used
cautiously, and we encourage origin servers to provide explicit
expiration times as much as possible.

.in 9
.ti 0
13.2.3.  Age Calculations
.in 3

In order to know if a cached entry is fresh, a cache needs to know if
its age exceeds its freshness lifetime.  We discuss how to calculate
the latter in Section\013.2.4; this section describes how to calculate
the age of a response or cache entry.

In this discussion, we use the term "now" to mean "the current value
of the clock at the host performing the calculation."  Hosts that use
HTTP, but especially hosts running origin servers and caches, SHOULD
use NTP [28] or some similar protocol to synchronize their clocks to
a globally accurate time standard.

HTTP/1.1 requires origin servers to send a Date header, if possible,
with every response, giving the time at which the response was
generated (see Section\014.18).  We use the term "date_value" to
denote the value of the Date header, in a form appropriate for
arithmetic operations.

HTTP/1.1 uses the Age \%response-header to convey the estimated age of
the response message when obtained from a cache.  The Age field value
is the cache\'s estimate of the amount of time since the response was
generated or revalidated by the origin server.

In essence, the Age value is the sum of the time that the response
has been resident in each of the caches along the path from the
origin server, plus the amount of time it has been in transit along
network paths.

We use the term "age_value" to denote the value of the Age header, in
a form appropriate for arithmetic operations.

A response\'s age can be calculated in two entirely independent ways:

.in 7
.ti 3
1.  now minus date_value, if the local clock is reasonably well
synchronized to the origin server\'s clock.  If the result is
negative, the result is replaced by zero.

.ti 3
2.  age_value, if all of the caches along the response path implement
HTTP/1.1.

.in 3
Given that we have two independent ways to compute the age of a
.bp
response when it is received, we can combine these as
.nf

    corrected_received_age = max(now - date_value, age_value)

.fi
and as long as we have either nearly synchronized clocks or \%all-
HTTP/1.1 paths, one gets a reliable (conservative) result.

Because of \%network-imposed delays, some significant interval might
pass between the time that a server generates a response and the time
it is received at the next outbound cache or client.  If uncorrected,
this delay could result in improperly low ages.

Because the request that resulted in the returned Age value must have
been initiated prior to that Age value\'s generation, we can correct
for delays imposed by the network by recording the time at which the
request was initiated.  Then, when an Age value is received, it MUST
be interpreted relative to the time the request was initiated, not
the time that the response was received.  This algorithm results in
conservative behavior no matter how much delay is experienced.  So,
we compute:
.nf

   corrected_initial_age = corrected_received_age
                         + (now - request_time)

.fi
where "request_time" is the time (according to the local clock) when
the request that elicited this response was sent.

Summary of age calculation algorithm, when a cache receives a
response:
.bp
.nf
   /*
    * age_value
    *      is the value of Age: header received by the cache with
    *              this response.
    * date_value
    *      is the value of the origin server\'s Date: header
    * request_time
    *      is the (local) time when the cache made the request
    *              that resulted in this cached response
    * response_time
    *      is the (local) time when the cache received the
    *              response
    * now
    *      is the current (local) time
    */

   apparent_age = max(0, response_time - date_value);
   corrected_received_age = max(apparent_age, age_value);
   response_delay = response_time - request_time;
   corrected_initial_age = corrected_received_age + response_delay;
   resident_time = now - response_time;
   current_age   = corrected_initial_age + resident_time;

.fi
The current_age of a cache entry is calculated by adding the amount
of time (in seconds) since the cache entry was last validated by the
origin server to the corrected_initial_age.  When a response is
generated from a cache entry, the cache MUST include a single Age
header field in the response with a value equal to the cache entry\'s
current_age.

The presence of an Age header field in a response implies that a
response is not \%first-hand.  However, the converse is not true, since
the lack of an Age header field in a response does not imply that the
response is \%first-hand unless all caches along the request path are
compliant with HTTP/1.1 (i.e., older HTTP caches did not implement
the Age header field).

.in 9
.ti 0
13.2.4.  Expiration Calculations
.in 3

In order to decide whether a response is fresh or stale, we need to
compare its freshness lifetime to its age.  The age is calculated as
described in Section\013.2.3; this section describes how to calculate
the freshness lifetime, and to determine if a response has expired.
In the discussion below, the values can be represented in any form
appropriate for arithmetic operations.

We use the term "expires_value" to denote the value of the Expires
header.  We use the term "max_age_value" to denote an appropriate
.bp
value of the number of seconds carried by the \%"max-age" directive of
the \%Cache-Control header in a response (see Section\014.9.3).

The \%max-age directive takes priority over Expires, so if \%max-age is
present in a response, the calculation is simply:
.nf

   freshness_lifetime = max_age_value

.fi
Otherwise, if Expires is present in the response, the calculation is:
.nf

   freshness_lifetime = expires_value - date_value

.fi
Note that neither of these calculations is vulnerable to clock skew,
since all of the information comes from the origin server.

If none of Expires, \%Cache-Control: \%max-age, or \%Cache-Control:
\%s-maxage (see Section\014.9.3) appears in the response, and the
response does not include other restrictions on caching, the cache
MAY compute a freshness lifetime using a heuristic.  The cache MUST
attach Warning 113 to any response whose age is more than 24 hours if
such warning has not already been added.

Also, if the response does have a \%Last-Modified time, the heuristic
expiration value SHOULD be no more than some fraction of the interval
since that time.  A typical setting of this fraction might be 10%.

The calculation to determine if a response has expired is quite
simple:
.nf

   response_is_fresh = (freshness_lifetime > current_age)

.fi
.in 9
.ti 0
13.2.5.  Disambiguating Expiration Values
.in 3

Because expiration values are assigned optimistically, it is possible
for two caches to contain fresh values for the same resource that are
different.

If a client performing a retrieval receives a \%non-first-hand response
for a request that was already fresh in its own cache, and the Date
header in its existing cache entry is newer than the Date on the new
response, then the client MAY ignore the response.  If so, it MAY
retry the request with a \%"Cache-Control: \%max-age=0" directive (see
Section\014.9), to force a check with the origin server.

If a cache has two fresh responses for the same representation with
different validators, it MUST use the one with the more recent Date
header.  This situation might arise because the cache is pooling
responses from other caches, or because a client has asked for a
.bp
reload or a revalidation of an apparently fresh cache entry.

.in 9
.ti 0
13.2.6.  Disambiguating Multiple Responses
.in 3

Because a client might be receiving responses via multiple paths, so
that some responses flow through one set of caches and other
responses flow through a different set of caches, a client might
receive responses in an order different from that in which the origin
server sent them.  We would like the client to use the most recently
generated response, even if older responses are still apparently
fresh.

Neither the entity tag nor the expiration value can impose an
ordering on responses, since it is possible that a later response
intentionally carries an earlier expiration time.  The Date values
are ordered to a granularity of one second.

When a client tries to revalidate a cache entry, and the response it
receives contains a Date header that appears to be older than the one
for the existing entry, then the client SHOULD repeat the request
unconditionally, and include
.nf

    Cache-Control: max-age=0

.fi
to force any intermediate caches to validate their copies directly
with the origin server, or
.nf

    Cache-Control: no-cache

.fi
to force any intermediate caches to obtain a new copy from the origin
server.

If the Date values are equal, then the client MAY use either response
(or MAY, if it is being extremely prudent, request a new response).
Servers MUST NOT depend on clients being able to choose
deterministically between responses generated during the same second,
if their expiration times overlap.

.in 7
.ti 0
13.3.  Validation Model
.in 3

When a cache has a stale entry that it would like to use as a
response to a client\'s request, it first has to check with the origin
server (or possibly an intermediate cache with a fresh response) to
see if its cached entry is still usable.  We call this "validating"
the cache entry.  Since we do not want to have to pay the overhead of
retransmitting the full response if the cached entry is good, and we
do not want to pay the overhead of an extra round trip if the cached
entry is invalid, the HTTP/1.1 protocol supports the use of
.bp
conditional methods.

The key protocol features for supporting conditional methods are
those concerned with "cache validators."  When an origin server
generates a full response, it attaches some sort of validator to it,
which is kept with the cache entry.  When a client (user agent or
proxy cache) makes a conditional request for a resource for which it
has a cache entry, it includes the associated validator in the
request.

The server then checks that validator against the current validator
for the entity, and, if they match (see Section\013.3.3), it responds
with a special status code (usually, 304 (Not Modified)) and no
\%entity-body.  Otherwise, it returns a full response (including
\%entity-body).  Thus, we avoid transmitting the full response if the
validator matches, and we avoid an extra round trip if it does not
match.

In HTTP/1.1, a conditional request looks exactly the same as a normal
request for the same resource, except that it carries a special
header (which includes the validator) that implicitly turns the
method (usually, GET) into a conditional.

The protocol includes both positive and negative senses of \%cache-
validating conditions.  That is, it is possible to request either
that a method be performed if and only if a validator matches or if
and only if no validators match.

.in 6
.ti 6
Note: a response that lacks a validator may still be cached, and
served from cache until it expires, unless this is explicitly
prohibited by a \%cache-control directive.  However, a cache cannot
do a conditional retrieval if it does not have a validator for the
entity, which means it will not be refreshable after it expires.

.in 3
.in 9
.ti 0
13.3.1.  \%Last-Modified Dates
.in 3

The \%Last-Modified \%entity-header field value is often used as a cache
validator.  In simple terms, a cache entry is considered to be valid
if the entity has not been modified since the \%Last-Modified value.

.in 9
.ti 0
13.3.2.  Entity Tag Cache Validators
.in 3

The ETag \%response-header field value, an entity tag, provides for an
"opaque" cache validator.  This might allow more reliable validation
in situations where it is inconvenient to store modification dates,
where the \%one-second resolution of HTTP date values is not
sufficient, or where the origin server wishes to avoid certain
paradoxes that might arise from the use of modification dates.
.bp
Entity Tags are described in Section\03.11.  The headers used with
entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.

.in 9
.ti 0
13.3.3.  Weak and Strong Validators
.in 3

Since both origin servers and caches will compare two validators to
decide if they represent the same or different entities, one normally
would expect that if the entity (the \%entity-body or any \%entity-
headers) changes in any way, then the associated validator would
change as well.  If this is true, then we call this validator a
"strong validator."

However, there might be cases when a server prefers to change the
validator only on semantically significant changes, and not when
insignificant aspects of the entity change.  A validator that does
not always change when the resource changes is a "weak validator."

Entity tags are normally "strong validators," but the protocol
provides a mechanism to tag an entity tag as "weak."  One can think
of a strong validator as one that changes whenever the bits of an
entity changes, while a weak value changes whenever the meaning of an
entity changes.  Alternatively, one can think of a strong validator
as part of an identifier for a specific entity, while a weak
validator is part of an identifier for a set of semantically
equivalent entities.

.in 6
.ti 6
Note: One example of a strong validator is an integer that is
incremented in stable storage every time an entity is changed.

.ti 6
An entity\'s modification time, if represented with \%one-second
resolution, could be a weak validator, since it is possible that
the resource might be modified twice during a single second.

.ti 6
Support for weak validators is optional.  However, weak validators
allow for more efficient caching of equivalent objects; for
example, a hit counter on a site is probably good enough if it is
updated every few days or weeks, and any value during that period
is likely "good enough" to be equivalent.

.in 3
A "use" of a validator is either when a client generates a request
and includes the validator in a validating header field, or when a
server compares two validators.

Strong validators are usable in any context.  Weak validators are
only usable in contexts that do not depend on exact equality of an
entity.  For example, either kind is usable for a conditional GET of
a full entity.  However, only a strong validator is usable for a \%sub-
range retrieval, since otherwise the client might end up with an
.bp
internally inconsistent entity.

Clients MAY issue simple \%(non-subrange) GET requests with either weak
validators or strong validators.  Clients MUST NOT use weak
validators in other forms of request.

The only function that the HTTP/1.1 protocol defines on validators is
comparison.  There are two validator comparison functions, depending
on whether the comparison context allows the use of weak validators
or not:

.in 6
.ti 3
o  The strong comparison function: in order to be considered equal,
both validators MUST be identical in every way, and both MUST NOT
be weak.

.ti 3
o  The weak comparison function: in order to be considered equal,
both validators MUST be identical in every way, but either or both
of them MAY be tagged as "weak" without affecting the result.

.in 3
An entity tag is strong unless it is explicitly tagged as weak.
Section\03.11 gives the syntax for entity tags.

A \%Last-Modified time, when used as a validator in a request, is
implicitly weak unless it is possible to deduce that it is strong,
using the following rules:

.in 6
.ti 3
o  The validator is being compared by an origin server to the actual
current validator for the entity and,

.ti 3
o  That origin server reliably knows that the associated entity did
not change twice during the second covered by the presented
validator.

.in 3
or

.in 6
.ti 3
o  The validator is about to be used by a client in an \%If-Modified-
Since or \%If-Unmodified-Since header, because the client has a
cache entry for the associated entity, and

.ti 3
o  That cache entry includes a Date value, which gives the time when
the origin server sent the original response, and

.ti 3
o  The presented \%Last-Modified time is at least 60 seconds before the
Date value.

.in 3
or
.bp
.in 6
.ti 3
o  The validator is being compared by an intermediate cache to the
validator stored in its cache entry for the entity, and

.ti 3
o  That cache entry includes a Date value, which gives the time when
the origin server sent the original response, and

.ti 3
o  The presented \%Last-Modified time is at least 60 seconds before the
Date value.

.in 3
This method relies on the fact that if two different responses were
sent by the origin server during the same second, but both had the
same \%Last-Modified time, then at least one of those responses would
have a Date value equal to its \%Last-Modified time.  The arbitrary \%60-
second limit guards against the possibility that the Date and \%Last-
Modified values are generated from different clocks, or at somewhat
different times during the preparation of the response.  An
implementation MAY use a value larger than 60 seconds, if it is
believed that 60 seconds is too short.

If a client wishes to perform a \%sub-range retrieval on a value for
which it has only a \%Last-Modified time and no opaque validator, it
MAY do this only if the \%Last-Modified time is strong in the sense
described here.

A cache or origin server receiving a conditional request, other than
a \%full-body GET request, MUST use the strong comparison function to
evaluate the condition.

These rules allow HTTP/1.1 caches and clients to safely perform \%sub-
range retrievals on values that have been obtained from HTTP/1.0
servers.

.in 9
.ti 0
13.3.4.  Rules for When to Use Entity Tags and \%Last-Modified Dates
.in 3

We adopt a set of rules and recommendations for origin servers,
clients, and caches regarding when various validator types ought to
be used, and for what purposes.

HTTP/1.1 origin servers:

.in 6
.ti 3
o  SHOULD send an entity tag validator unless it is not feasible to
generate one.

.ti 3
o  MAY send a weak entity tag instead of a strong entity tag, if
performance considerations support the use of weak entity tags, or
if it is unfeasible to send a strong entity tag.
.bp
.ti 3
o  SHOULD send a \%Last-Modified value if it is feasible to send one,
unless the risk of a breakdown in semantic transparency that could
result from using this date in an \%If-Modified-Since header would
lead to serious problems.

.in 3
In other words, the preferred behavior for an HTTP/1.1 origin server
is to send both a strong entity tag and a \%Last-Modified value.

In order to be legal, a strong entity tag MUST change whenever the
associated entity value changes in any way.  A weak entity tag SHOULD
change whenever the associated entity changes in a semantically
significant way.

.in 6
.ti 6
Note: in order to provide semantically transparent caching, an
origin server must avoid reusing a specific strong entity tag
value for two different entities, or reusing a specific weak
entity tag value for two semantically different entities.  Cache
entries might persist for arbitrarily long periods, regardless of
expiration times, so it might be inappropriate to expect that a
cache will never again attempt to validate an entry using a
validator that it obtained at some point in the past.

.in 3
HTTP/1.1 clients:

.in 6
.ti 3
o  If an entity tag has been provided by the origin server, MUST use
that entity tag in any \%cache-conditional request (using \%If-Match
or \%If-None-Match).

.ti 3
o  If only a \%Last-Modified value has been provided by the origin
server, SHOULD use that value in \%non-subrange \%cache-conditional
requests (using \%If-Modified-Since).

.ti 3
o  If only a \%Last-Modified value has been provided by an HTTP/1.0
origin server, MAY use that value in subrange \%cache-conditional
requests (using \%If-Unmodified-Since:).  The user agent SHOULD
provide a way to disable this, in case of difficulty.

.ti 3
o  If both an entity tag and a \%Last-Modified value have been provided
by the origin server, SHOULD use both validators in \%cache-
conditional requests.  This allows both HTTP/1.0 and HTTP/1.1
caches to respond appropriately.

.in 3
An HTTP/1.1 origin server, upon receiving a conditional request that
includes both a \%Last-Modified date (e.g., in an \%If-Modified-Since or
\%If-Unmodified-Since header field) and one or more entity tags (e.g.,
in an \%If-Match, \%If-None-Match, or \%If-Range header field) as cache
validators, MUST NOT return a response status of 304 (Not Modified)
unless doing so is consistent with all of the conditional header
.bp
fields in the request.

An HTTP/1.1 caching proxy, upon receiving a conditional request that
includes both a \%Last-Modified date and one or more entity tags as
cache validators, MUST NOT return a locally cached response to the
client unless that cached response is consistent with all of the
conditional header fields in the request.

.in 6
.ti 6
Note: The general principle behind these rules is that HTTP/1.1
servers and clients should transmit as much \%non-redundant
information as is available in their responses and requests.
HTTP/1.1 systems receiving this information will make the most
conservative assumptions about the validators they receive.

.ti 6
HTTP/1.0 clients and caches will ignore entity tags.  Generally,
\%last-modified values received or used by these systems will
support transparent and efficient caching, and so HTTP/1.1 origin
servers should provide \%Last-Modified values.  In those rare cases
where the use of a \%Last-Modified value as a validator by an
HTTP/1.0 system could result in a serious problem, then HTTP/1.1
origin servers should not provide one.

.in 3
.in 9
.ti 0
13.3.5.  \%Non-validating Conditionals
.in 3

The principle behind entity tags is that only the service author
knows the semantics of a resource well enough to select an
appropriate cache validation mechanism, and the specification of any
validator comparison function more complex than \%byte-equality would
open up a can of worms.  Thus, comparisons of any other headers
(except \%Last-Modified, for compatibility with HTTP/1.0) are never
used for purposes of validating a cache entry.

.in 7
.ti 0
13.4.  Response Cacheability
.in 3

Unless specifically constrained by a \%cache-control (Section\014.9)
directive, a caching system MAY always store a successful response
(see Section\013.8) as a cache entry, MAY return it without validation
if it is fresh, and MAY return it after successful validation.  If
there is neither a cache validator nor an explicit expiration time
associated with a response, we do not expect it to be cached, but
certain caches MAY violate this expectation (for example, when little
or no network connectivity is available).  A client can usually
detect that such a response was taken from a cache by comparing the
Date header to the current time.

.in 6
.ti 6
Note: some HTTP/1.0 caches are known to violate this expectation
without providing any Warning.

.bp
.in 3
However, in some cases it might be inappropriate for a cache to
retain an entity, or to return it in response to a subsequent
request.  This might be because absolute semantic transparency is
deemed necessary by the service author, or because of security or
privacy considerations.  Certain \%cache-control directives are
therefore provided so that the server can indicate that certain
resource entities, or portions thereof, are not to be cached
regardless of other considerations.

Note that Section\014.8 normally prevents a shared cache from saving
and returning a response to a previous request if that request
included an Authorization header.

A response received with a status code of 200, 203, 206, 300, 301 or
410 MAY be stored by a cache and used in reply to a subsequent
request, subject to the expiration mechanism, unless a \%cache-control
directive prohibits caching.  However, a cache that does not support
the Range and \%Content-Range headers MUST NOT cache 206 (Partial
Content) responses.

A response received with any other status code (e.g. status codes 302
and 307) MUST NOT be returned in a reply to a subsequent request
unless there are \%cache-control directives or another header(s) that
explicitly allow it.  For example, these include the following: an
Expires header (Section\014.21); a \%"max-age", \%"s-maxage", \%"must-
revalidate", \%"proxy-revalidate", "public" or "private" \%cache-control
directive (Section\014.9).

.in 7
.ti 0
13.5.  Constructing Responses From Caches
.in 3

The purpose of an HTTP cache is to store information received in
response to requests for use in responding to future requests.  In
many cases, a cache simply returns the appropriate parts of a
response to the requester.  However, if the cache holds a cache entry
based on a previous response, it might have to combine parts of a new
response with what is held in the cache entry.

.in 9
.ti 0
13.5.1.  \%End-to-end and \%Hop-by-hop Headers
.in 3

For the purpose of defining the behavior of caches and \%non-caching
proxies, we divide HTTP headers into two categories:

.in 6
.ti 3
o  \%End-to-end headers, which are transmitted to the ultimate
recipient of a request or response.  \%End-to-end headers in
responses MUST be stored as part of a cache entry and MUST be
transmitted in any response formed from a cache entry.
.bp
.ti 3
o  \%Hop-by-hop headers, which are meaningful only for a single
\%transport-level connection, and are not stored by caches or
forwarded by proxies.

.in 3
The following HTTP/1.1 headers are \%hop-by-hop headers:

.in 6
.ti 3
o  Connection

.ti 3
o  \%Keep-Alive

.ti 3
o  \%Proxy-Authenticate

.ti 3
o  \%Proxy-Authorization

.ti 3
o  TE

.ti 3
o  Trailers

.ti 3
o  \%Transfer-Encoding

.ti 3
o  Upgrade

.in 3
All other headers defined by HTTP/1.1 are \%end-to-end headers.

Other \%hop-by-hop headers MUST be listed in a Connection header,
(Section\014.10) to be introduced into HTTP/1.1 (or later).

.in 9
.ti 0
13.5.2.  \%Non-modifiable Headers
.in 3

Some features of the HTTP/1.1 protocol, such as Digest
Authentication, depend on the value of certain \%end-to-end headers.  A
transparent proxy SHOULD NOT modify an \%end-to-end header unless the
definition of that header requires or specifically allows that.

A transparent proxy MUST NOT modify any of the following fields in a
request or response, and it MUST NOT add any of these fields if not
already present:

.in 6
.ti 3
o  \%Content-Location

.ti 3
o  \%Content-MD5

.ti 3
o  ETag

.ti 3
o  \%Last-Modified

.in 3
A transparent proxy MUST NOT modify any of the following fields in a
response:
.bp
.in 6
.ti 3
o  Expires

.in 3
but it MAY add any of these fields if not already present.  If an
Expires header is added, it MUST be given a \%field-value identical to
that of the Date header in that response.

A proxy MUST NOT modify or add any of the following fields in a
message that contains the \%no-transform \%cache-control directive, or in
any request:

.in 6
.ti 3
o  \%Content-Encoding

.ti 3
o  \%Content-Range

.ti 3
o  \%Content-Type

.in 3
A \%non-transparent proxy MAY modify or add these fields to a message
that does not include \%no-transform, but if it does so, it MUST add a
Warning 214 (Transformation applied) if one does not already appear
in the message (see Section\014.46).

.in 6
.ti 6
Warning: unnecessary modification of \%end-to-end headers might
cause authentication failures if stronger authentication
mechanisms are introduced in later versions of HTTP.  Such
authentication mechanisms MAY rely on the values of header fields
not listed here.

.in 3
The \%Content-Length field of a request or response is added or deleted
according to the rules in Section\04.4.  A transparent proxy MUST
preserve the \%entity-length (Section\07.2.2) of the \%entity-body,
although it MAY change the \%transfer-length (Section\04.4).

.in 9
.ti 0
13.5.3.  Combining Headers
.in 3

When a cache makes a validating request to a server, and the server
provides a 304 (Not Modified) response or a 206 (Partial Content)
response, the cache then constructs a response to send to the
requesting client.

If the status code is 304 (Not Modified), the cache uses the \%entity-
body stored in the cache entry as the \%entity-body of this outgoing
response.  If the status code is 206 (Partial Content) and the ETag
or \%Last-Modified headers match exactly, the cache MAY combine the
contents stored in the cache entry with the new contents received in
the response and use the result as the \%entity-body of this outgoing
response, (see 13.5.4).

The \%end-to-end headers stored in the cache entry are used for the
.bp
constructed response, except that

.in 6
.ti 3
o  any stored Warning headers with \%warn-code 1xx (see Section\014.46)
MUST be deleted from the cache entry and the forwarded response.

.ti 3
o  any stored Warning headers with \%warn-code 2xx MUST be retained in
the cache entry and the forwarded response.

.ti 3
o  any \%end-to-end headers provided in the 304 or 206 response MUST
replace the corresponding headers from the cache entry.

.in 3
Unless the cache decides to remove the cache entry, it MUST also
replace the \%end-to-end headers stored with the cache entry with
corresponding headers received in the incoming response, except for
Warning headers as described immediately above.  If a header \%field-
name in the incoming response matches more than one header in the
cache entry, all such old headers MUST be replaced.

In other words, the set of \%end-to-end headers received in the
incoming response overrides all corresponding \%end-to-end headers
stored with the cache entry (except for stored Warning headers with
\%warn-code 1xx, which are deleted even if not overridden).

.in 6
.ti 6
Note: this rule allows an origin server to use a 304 (Not
Modified) or a 206 (Partial Content) response to update any header
associated with a previous response for the same entity or \%sub-
ranges thereof, although it might not always be meaningful or
correct to do so.  This rule does not allow an origin server to
use a 304 (Not Modified) or a 206 (Partial Content) response to
entirely delete a header that it had provided with a previous
response.

.in 3
.in 9
.ti 0
13.5.4.  Combining Byte Ranges
.in 3

A response might transfer only a subrange of the bytes of an \%entity-
body, either because the request included one or more Range
specifications, or because a connection was broken prematurely.
After several such transfers, a cache might have received several
ranges of the same \%entity-body.

If a cache has a stored \%non-empty set of subranges for an entity, and
an incoming response transfers another subrange, the cache MAY
combine the new subrange with the existing set if both the following
conditions are met:

.in 6
.ti 3
o  Both the incoming response and the cache entry have a cache
validator.
.bp
.ti 3
o  The two cache validators match using the strong comparison
function (see Section\013.3.3).

.in 3
If either requirement is not met, the cache MUST use only the most
recent partial response (based on the Date values transmitted with
every response, and using the incoming response if these values are
equal or missing), and MUST discard the other partial information.

.in 7
.ti 0
13.6.  Caching Negotiated Responses
.in 3

Use of \%server-driven content negotiation (Section\012.1), as indicated
by the presence of a Vary header field in a response, alters the
conditions and procedure by which a cache can use the response for
subsequent requests.  See Section\014.44 for use of the Vary header
field by servers.

A server SHOULD use the Vary header field to inform a cache of what
\%request-header fields were used to select among multiple
representations of a cacheable response subject to \%server-driven
negotiation.  The set of header fields named by the Vary field value
is known as the "selecting" \%request-headers.

When the cache receives a subsequent request whose \%Request-URI
specifies one or more cache entries including a Vary header field,
the cache MUST NOT use such a cache entry to construct a response to
the new request unless all of the selecting \%request-headers present
in the new request match the corresponding stored \%request-headers in
the original request.

The selecting \%request-headers from two requests are defined to match
if and only if the selecting \%request-headers in the first request can
be transformed to the selecting \%request-headers in the second request
by adding or removing linear white space (LWS) at places where this
is allowed by the corresponding BNF, and/or combining multiple
\%message-header fields with the same field name following the rules
about message headers in Section\04.2.

A Vary header \%field-value of "*" always fails to match and subsequent
requests on that resource can only be properly interpreted by the
origin server.

If the selecting request header fields for the cached entry do not
match the selecting request header fields of the new request, then
the cache MUST NOT use a cached entry to satisfy the request unless
it first relays the new request to the origin server in a conditional
request and the server responds with 304 (Not Modified), including an
entity tag or \%Content-Location that indicates the entity to be used.

.bp
If an entity tag was assigned to a cached representation, the
forwarded request SHOULD be conditional and include the entity tags
in an \%If-None-Match header field from all its cache entries for the
resource.  This conveys to the server the set of entities currently
held by the cache, so that if any one of these entities matches the
requested entity, the server can use the ETag header field in its 304
(Not Modified) response to tell the cache which entry is appropriate.
If the \%entity-tag of the new response matches that of an existing
entry, the new response SHOULD be used to update the header fields of
the existing entry, and the result MUST be returned to the client.

If any of the existing cache entries contains only partial content
for the associated entity, its \%entity-tag SHOULD NOT be included in
the \%If-None-Match header field unless the request is for a range that
would be fully satisfied by that entry.

If a cache receives a successful response whose \%Content-Location
field matches that of an existing cache entry for the same \%Request-
URI, whose \%entity-tag differs from that of the existing entry, and
whose Date is more recent than that of the existing entry, the
existing entry SHOULD NOT be returned in response to future requests
and SHOULD be deleted from the cache.

.in 7
.ti 0
13.7.  Shared and \%Non-Shared Caches
.in 3

For reasons of security and privacy, it is necessary to make a
distinction between "shared" and \%"non-shared" caches.  A \%non-shared
cache is one that is accessible only to a single user.  Accessibility
in this case SHOULD be enforced by appropriate security mechanisms.
All other caches are considered to be "shared."  Other sections of
this specification place certain constraints on the operation of
shared caches in order to prevent loss of privacy or failure of
access controls.

.in 7
.ti 0
13.8.  Errors or Incomplete Response Cache Behavior
.in 3

A cache that receives an incomplete response (for example, with fewer
bytes of data than specified in a \%Content-Length header) MAY store
the response.  However, the cache MUST treat this as a partial
response.  Partial responses MAY be combined as described in
Section\013.5.4; the result might be a full response or might still be
partial.  A cache MUST NOT return a partial response to a client
without explicitly marking it as such, using the 206 (Partial
Content) status code.  A cache MUST NOT return a partial response
using a status code of 200 (OK).

If a cache receives a 5xx response while attempting to revalidate an
entry, it MAY either forward this response to the requesting client,
.bp
or act as if the server failed to respond.  In the latter case, it
MAY return a previously received response unless the cached entry
includes the \%"must-revalidate" \%cache-control directive (see
Section\014.9).

.in 7
.ti 0
13.9.  Side Effects of GET and HEAD
.in 3

Unless the origin server explicitly prohibits the caching of their
responses, the application of GET and HEAD methods to any resources
SHOULD NOT have side effects that would lead to erroneous behavior if
these responses are taken from a cache.  They MAY still have side
effects, but a cache is not required to consider such side effects in
its caching decisions.  Caches are always expected to observe an
origin server\'s explicit restrictions on caching.

We note one exception to this rule: since some applications have
traditionally used GETs and HEADs with query URLs (those containing a
"?" in the rel_path part) to perform operations with significant side
effects, caches MUST NOT treat responses to such URIs as fresh unless
the server provides an explicit expiration time.  This specifically
means that responses from HTTP/1.0 servers for such URIs SHOULD NOT
be taken from a cache.  See Section\09.1.1 for related information.

.in 8
.ti 0
13.10.  Invalidation After Updates or Deletions
.in 3

The effect of certain methods performed on a resource at the origin
server might cause one or more existing cache entries to become \%non-
transparently invalid.  That is, although they might continue to be
"fresh," they do not accurately reflect what the origin server would
return for a new request on that resource.

There is no way for the HTTP protocol to guarantee that all such
cache entries are marked invalid.  For example, the request that
caused the change at the origin server might not have gone through
the proxy where a cache entry is stored.  However, several rules help
reduce the likelihood of erroneous behavior.

In this section, the phrase "invalidate an entity" means that the
cache will either remove all instances of that entity from its
storage, or will mark these as "invalid" and in need of a mandatory
revalidation before they can be returned in response to a subsequent
request.

Some HTTP methods MUST cause a cache to invalidate an entity.  This
is either the entity referred to by the \%Request-URI, or by the
Location or \%Content-Location headers (if present).  These methods
are:
.bp
.in 6
.ti 3
o  PUT

.ti 3
o  DELETE

.ti 3
o  POST

.in 3
In order to prevent denial of service attacks, an invalidation based
on the URI in a Location or \%Content-Location header MUST only be
performed if the host part is the same as in the \%Request-URI.

A cache that passes through requests for methods it does not
understand SHOULD invalidate any entities referred to by the \%Request-
URI.

.in 8
.ti 0
13.11.  \%Write-Through Mandatory
.in 3

All methods that might be expected to cause modifications to the
origin server\'s resources MUST be written through to the origin
server.  This currently includes all methods except for GET and HEAD.
A cache MUST NOT reply to such a request from a client before having
transmitted the request to the inbound server, and having received a
corresponding response from the inbound server.  This does not
prevent a proxy cache from sending a 100 (Continue) response before
the inbound server has sent its final reply.

The alternative (known as \%"write-back" or \%"copy-back" caching) is not
allowed in HTTP/1.1, due to the difficulty of providing consistent
updates and the problems arising from server, cache, or network
failure prior to \%write-back.

.in 8
.ti 0
13.12.  Cache Replacement
.in 3

If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8)
response is received from a resource while any existing responses for
the same resource are cached, the cache SHOULD use the new response
to reply to the current request.  It MAY insert it into cache storage
and MAY, if it meets all other requirements, use it to respond to any
future requests that would previously have caused the old response to
be returned.  If it inserts the new response into cache storage the
rules in Section\013.5.3 apply.

.in 6
.ti 6
Note: a new response that has an older Date header value than
existing cached responses is not cacheable.

.in 3
.bp
.in 8
.ti 0
13.13.  History Lists
.in 3

User agents often have history mechanisms, such as "Back" buttons and
history lists, which can be used to redisplay an entity retrieved
earlier in a session.

History mechanisms and caches are different.  In particular history
mechanisms SHOULD NOT try to show a semantically transparent view of
the current state of a resource.  Rather, a history mechanism is
meant to show exactly what the user saw at the time when the resource
was retrieved.

By default, an expiration time does not apply to history mechanisms.
If the entity is still in storage, a history mechanism SHOULD display
it even if the entity has expired, unless the user has specifically
configured the agent to refresh expired history documents.

This is not to be construed to prohibit the history mechanism from
telling the user that a view might be stale.

.in 6
.ti 6
Note: if history list mechanisms unnecessarily prevent users from
viewing stale resources, this will tend to force service authors
to avoid using HTTP expiration controls and cache controls when
they would otherwise like to.  Service authors may consider it
important that users not be presented with error messages or
warning messages when they use navigation controls (such as BACK)
to view previously fetched resources.  Even though sometimes such
resources ought not to cached, or ought to expire quickly, user
interface considerations may force service authors to resort to
other means of preventing caching (e.g. \%"once-only" URLs) in order
not to suffer the effects of improperly functioning history
mechanisms.

.in 3
.bp
.in 5
.ti 0
14.  Header Field Definitions
.in 3

This section defines the syntax and semantics of all standard
HTTP/1.1 header fields.  For \%entity-header fields, both sender and
recipient refer to either the client or the server, depending on who
sends and who receives the entity.

.in 7
.ti 0
14.1.  Accept
.in 3

The Accept \%request-header field can be used to specify certain media
types which are acceptable for the response.  Accept headers can be
used to indicate that the request is specifically limited to a small
set of desired types, as in the case of a request for an \%in-line
image.
.nf

    Accept         = "Accept" ":"
                     #( media-range [ accept-params ] )

    media-range    = ( "*/*"
                     | ( type "/" "*" )
                     | ( type "/" subtype )
                     ) *( ";" parameter )
    accept-params  = ";" "q" "=" qvalue *( accept-extension )
    accept-extension = ";" token [ "=" ( token | quoted-string ) ]

.fi
The asterisk "*" character is used to group media types into ranges,
with "*/*" indicating all media types and "type/*" indicating all
subtypes of that type.  The \%media-range MAY include media type
parameters that are applicable to that range.

Each \%media-range MAY be followed by one or more \%accept-params,
beginning with the "q" parameter for indicating a relative quality
factor.  The first "q" parameter (if any) separates the \%media-range
parameter(s) from the \%accept-params.  Quality factors allow the user
or user agent to indicate the relative degree of preference for that
\%media-range, using the qvalue scale from 0 to 1 (Section\03.9).  The
default value is q=1.

.in 6
.ti 6
Note: Use of the "q" parameter name to separate media type
parameters from Accept extension parameters is due to historical
practice.  Although this prevents any media type parameter named
"q" from being used with a media range, such an event is believed
to be unlikely given the lack of any "q" parameters in the IANA
media type registry and the rare usage of any media type
parameters in Accept.  Future media types are discouraged from
registering any parameter named "q".

.in 3
The example
.bp
.nf
    Accept: audio/*; q=0.2, audio/basic

.fi
SHOULD be interpreted as "I prefer audio/basic, but send me any audio
type if it is the best available after an 80% \%mark-down in quality."

If no Accept header field is present, then it is assumed that the
client accepts all media types.  If an Accept header field is
present, and if the server cannot send a response which is acceptable
according to the combined Accept field value, then the server SHOULD
send a 406 (not acceptable) response.

A more elaborate example is
.nf

    Accept: text/plain; q=0.5, text/html,
            text/x-dvi; q=0.8, text/x-c

.fi
Verbally, this would be interpreted as "text/html and \%text/x-c are
the preferred media types, but if they do not exist, then send the
\%text/x-dvi entity, and if that does not exist, send the text/plain
entity."

Media ranges can be overridden by more specific media ranges or
specific media types.  If more than one media range applies to a
given type, the most specific reference has precedence.  For example,
.nf

    Accept: text/*, text/html, text/html;level=1, */*

.fi
have the following precedence:
.nf

    1) text/html;level=1
    2) text/html
    3) text/*
    4) */*

.fi
The media type quality factor associated with a given type is
determined by finding the media range with the highest precedence
which matches that type.  For example,
.nf

    Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
            text/html;level=2;q=0.4, */*;q=0.5

.fi
would cause the following values to be associated:
.nf

    text/html;level=1         = 1
    text/html                 = 0.7
    text/plain                = 0.3
    image/jpeg                = 0.5
    text/html;level=2         = 0.4
.bp
    text/html;level=3         = 0.7

.fi
Note: A user agent might be provided with a default set of quality
values for certain media ranges.  However, unless the user agent is a
closed system which cannot interact with other rendering agents, this
default set ought to be configurable by the user.

.in 7
.ti 0
14.2.  \%Accept-Charset
.in 3

The \%Accept-Charset \%request-header field can be used to indicate what
character sets are acceptable for the response.  This field allows
clients capable of understanding more comprehensive or \%special-
purpose character sets to signal that capability to a server which is
capable of representing documents in those character sets.
.nf

   Accept-Charset = "Accept-Charset" ":"
           1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )

.fi
Character set values are described in Section\03.4.  Each charset MAY
be given an associated quality value which represents the user\'s
preference for that charset.  The default value is q=1.  An example
is
.nf

   Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

.fi
The special value "*", if present in the \%Accept-Charset field,
matches every character set (including \%ISO-8859-1) which is not
mentioned elsewhere in the \%Accept-Charset field.  If no "*" is
present in an \%Accept-Charset field, then all character sets not
explicitly mentioned get a quality value of 0, except for \%ISO-8859-1,
which gets a quality value of 1 if not explicitly mentioned.

If no \%Accept-Charset header is present, the default is that any
character set is acceptable.  If an \%Accept-Charset header is present,
and if the server cannot send a response which is acceptable
according to the \%Accept-Charset header, then the server SHOULD send
an error response with the 406 (not acceptable) status code, though
the sending of an unacceptable response is also allowed.

.in 7
.ti 0
14.3.  \%Accept-Encoding
.in 3

The \%Accept-Encoding \%request-header field is similar to Accept, but
restricts the \%content-codings (Section\03.5) that are acceptable in
the response.
.nf

    Accept-Encoding  = "Accept-Encoding" ":"
                       1#( codings [ ";" "q" "=" qvalue ] )
    codings          = ( content-coding | "*" )
.bp
.fi
Examples of its use are:
.nf

    Accept-Encoding: compress, gzip
    Accept-Encoding:
    Accept-Encoding: *
    Accept-Encoding: compress;q=0.5, gzip;q=1.0
    Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

.fi
A server tests whether a \%content-coding is acceptable, according to
an \%Accept-Encoding field, using these rules:

.in 7
.ti 3
1.  If the \%content-coding is one of the \%content-codings listed in the
\%Accept-Encoding field, then it is acceptable, unless it is
accompanied by a qvalue of 0.  (As defined in Section\03.9, a
qvalue of 0 means "not acceptable.")

.ti 3
2.  The special "*" symbol in an \%Accept-Encoding field matches any
available \%content-coding not explicitly listed in the header
field.

.ti 3
3.  If multiple \%content-codings are acceptable, then the acceptable
\%content-coding with the highest \%non-zero qvalue is preferred.

.ti 3
4.  The "identity" \%content-coding is always acceptable, unless
specifically refused because the \%Accept-Encoding field includes
"identity;q=0", or because the field includes "*;q=0" and does
not explicitly include the "identity" \%content-coding.  If the
\%Accept-Encoding \%field-value is empty, then only the "identity"
encoding is acceptable.

.in 3
If an \%Accept-Encoding field is present in a request, and if the
server cannot send a response which is acceptable according to the
\%Accept-Encoding header, then the server SHOULD send an error response
with the 406 (Not Acceptable) status code.

If no \%Accept-Encoding field is present in a request, the server MAY
assume that the client will accept any content coding.  In this case,
if "identity" is one of the available \%content-codings, then the
server SHOULD use the "identity" \%content-coding, unless it has
additional information that a different \%content-coding is meaningful
to the client.

.in 6
.ti 6
Note: If the request does not include an \%Accept-Encoding field,
and if the "identity" \%content-coding is unavailable, then \%content-
codings commonly understood by HTTP/1.0 clients (i.e., "gzip" and
"compress") are preferred; some older clients improperly display
messages sent with other \%content-codings.  The server might also
make this decision based on information about the particular \%user-
.bp
agent or client.

.ti 6
Note: Most HTTP/1.0 applications do not recognize or obey qvalues
associated with \%content-codings.  This means that qvalues will not
work and are not permitted with \%x-gzip or \%x-compress.

.in 3
.in 7
.ti 0
14.4.  \%Accept-Language
.in 3

The \%Accept-Language \%request-header field is similar to Accept, but
restricts the set of natural languages that are preferred as a
response to the request.  Language tags are defined in Section\03.10.
.nf

    Accept-Language = "Accept-Language" ":"
                      1#( language-range [ ";" "q" "=" qvalue ] )
    language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )

.fi
Each \%language-range MAY be given an associated quality value which
represents an estimate of the user\'s preference for the languages
specified by that range.  The quality value defaults to "q=1".  For
example,
.nf

    Accept-Language: da, en-gb;q=0.8, en;q=0.7

.fi
would mean: "I prefer Danish, but will accept British English and
other types of English."  A \%language-range matches a \%language-tag if
it exactly equals the tag, or if it exactly equals a prefix of the
tag such that the first tag character following the prefix is \%"-".
The special range "*", if present in the \%Accept-Language field,
matches every tag not matched by any other range present in the
\%Accept-Language field.

.in 6
.ti 6
Note: This use of a prefix matching rule does not imply that
language tags are assigned to languages in such a way that it is
always true that if a user understands a language with a certain
tag, then this user will also understand all languages with tags
for which this tag is a prefix.  The prefix rule simply allows the
use of prefix tags if this is the case.

.in 3
The language quality factor assigned to a \%language-tag by the \%Accept-
Language field is the quality value of the longest \%language-range in
the field that matches the \%language-tag.  If no \%language-range in the
field matches the tag, the language quality factor assigned is 0.  If
no \%Accept-Language header is present in the request, the server
SHOULD assume that all languages are equally acceptable.  If an
\%Accept-Language header is present, then all languages which are
assigned a quality factor greater than 0 are acceptable.

It might be contrary to the privacy expectations of the user to send
.bp
an \%Accept-Language header with the complete linguistic preferences of
the user in every request.  For a discussion of this issue, see
Section\015.1.4.

As intelligibility is highly dependent on the individual user, it is
recommended that client applications make the choice of linguistic
preference available to the user.  If the choice is not made
available, then the \%Accept-Language header field MUST NOT be given in
the request.

.in 6
.ti 6
Note: When making the choice of linguistic preference available to
the user, we remind implementors of the fact that users are not
familiar with the details of language matching as described above,
and should provide appropriate guidance.  As an example, users
might assume that on selecting \%"en-gb", they will be served any
kind of English document if British English is not available.  A
user agent might suggest in such a case to add "en" to get the
best matching behavior.

.in 3
.in 7
.ti 0
14.5.  \%Accept-Ranges
.in 3

The \%Accept-Ranges \%response-header field allows the server to indicate
its acceptance of range requests for a resource:
.nf

       Accept-Ranges     = "Accept-Ranges" ":" acceptable-ranges
       acceptable-ranges = 1#range-unit | "none"

.fi
Origin servers that accept \%byte-range requests MAY send
.nf

       Accept-Ranges: bytes

.fi
but are not required to do so.  Clients MAY generate \%byte-range
requests without having received this header for the resource
involved.  Range units are defined in Section\03.12.

Servers that do not accept any kind of range request for a resource
MAY send
.nf

       Accept-Ranges: none

.fi
to advise the client not to attempt a range request.

.in 7
.ti 0
14.6.  Age
.in 3

The Age \%response-header field conveys the sender\'s estimate of the
amount of time since the response (or its revalidation) was generated
at the origin server.  A cached response is "fresh" if its age does
not exceed its freshness lifetime.  Age values are calculated as
.bp
specified in Section\013.2.3.
.nf

        Age = "Age" ":" age-value
        age-value = delta-seconds

.fi
Age values are \%non-negative decimal integers, representing time in
seconds.

If a cache receives a value larger than the largest positive integer
it can represent, or if any of its age calculations overflows, it
MUST transmit an Age header with a value of 2147483648 (2^31).  An
HTTP/1.1 server that includes a cache MUST include an Age header
field in every response generated from its own cache.  Caches SHOULD
use an arithmetic type of at least 31 bits of range.

.in 7
.ti 0
14.7.  Allow
.in 3

The Allow \%entity-header field lists the set of methods supported by
the resource identified by the \%Request-URI.  The purpose of this
field is strictly to inform the recipient of valid methods associated
with the resource.  An Allow header field MUST be present in a 405
(Method Not Allowed) response.
.nf

       Allow   = "Allow" ":" #Method

.fi
Example of use:
.nf

       Allow: GET, HEAD, PUT

.fi
This field cannot prevent a client from trying other methods.
However, the indications given by the Allow header field value SHOULD
be followed.  The actual set of allowed methods is defined by the
origin server at the time of each request.

The Allow header field MAY be provided with a PUT request to
recommend the methods to be supported by the new or modified
resource.  The server is not required to support these methods and
SHOULD include an Allow header in the response giving the actual
supported methods.

A proxy MUST NOT modify the Allow header field even if it does not
understand all the methods specified, since the user agent might have
other means of communicating with the origin server.

.in 7
.ti 0
14.8.  Authorization
.in 3

A user agent that wishes to authenticate itself with a \%server--
usually, but not necessarily, after receiving a 401 \%response--does so
.bp
by including an Authorization \%request-header field with the request.
The Authorization field value consists of credentials containing the
authentication information of the user agent for the realm of the
resource being requested.
.nf

       Authorization  = "Authorization" ":" credentials

.fi
HTTP access authentication is described in "HTTP Authentication:
Basic and Digest Access Authentication" [43].  If a request is
authenticated and a realm specified, the same credentials SHOULD be
valid for all other requests within this realm (assuming that the
authentication scheme itself does not require otherwise, such as
credentials that vary according to a challenge value or using
synchronized clocks).

When a shared cache (see Section\013.7) receives a request containing
an Authorization field, it MUST NOT return the corresponding response
as a reply to any other request, unless one of the following specific
exceptions holds:

.in 7
.ti 3
1.  If the response includes the \%"s-maxage" \%cache-control directive,
the cache MAY use that response in replying to a subsequent
request.  But (if the specified maximum age has passed) a proxy
cache MUST first revalidate it with the origin server, using the
\%request-headers from the new request to allow the origin server
to authenticate the new request.  (This is the defined behavior
for \%s-maxage.)  If the response includes \%"s-maxage=0", the proxy
MUST always revalidate it before \%re-using it.

.ti 3
2.  If the response includes the \%"must-revalidate" \%cache-control
directive, the cache MAY use that response in replying to a
subsequent request.  But if the response is stale, all caches
MUST first revalidate it with the origin server, using the
\%request-headers from the new request to allow the origin server
to authenticate the new request.

.ti 3
3.  If the response includes the "public" \%cache-control directive, it
MAY be returned in reply to any subsequent request.

.in 3
.in 7
.ti 0
14.9.  \%Cache-Control
.in 3

The \%Cache-Control \%general-header field is used to specify directives
that MUST be obeyed by all caching mechanisms along the request/
response chain.  The directives specify behavior intended to prevent
caches from adversely interfering with the request or response.
These directives typically override the default caching algorithms.
Cache directives are unidirectional in that the presence of a
directive in a request does not imply that the same directive is to
.bp
be given in the response.

.in 6
.ti 6
Note that HTTP/1.0 caches might not implement \%Cache-Control and
might only implement Pragma: \%no-cache (see Section\014.32).

.in 3
Cache directives MUST be passed through by a proxy or gateway
application, regardless of their significance to that application,
since the directives might be applicable to all recipients along the
request/response chain.  It is not possible to specify a \%cache-
directive for a specific cache.
.nf

.in 2
   Cache-Control   = "Cache-Control" ":" 1#cache-directive

   cache-directive = cache-request-directive
        | cache-response-directive

   cache-request-directive =
          "no-cache"                          ; Section 14.9.1
        | "no-store"                          ; Section 14.9.2
        | "max-age" "=" delta-seconds         ; Section 14.9.3, 14.9.4
        | "max-stale" [ "=" delta-seconds ]   ; Section 14.9.3
        | "min-fresh" "=" delta-seconds       ; Section 14.9.3
        | "no-transform"                      ; Section 14.9.5
        | "only-if-cached"                    ; Section 14.9.4
        | cache-extension                     ; Section 14.9.6

    cache-response-directive =
          "public"                               ; Section 14.9.1
        | "private" [ "=" <"> 1#field-name <"> ] ; Section 14.9.1
        | "no-cache" [ "=" <"> 1#field-name <"> ]; Section 14.9.1
        | "no-store"                             ; Section 14.9.2
        | "no-transform"                         ; Section 14.9.5
        | "must-revalidate"                      ; Section 14.9.4
        | "proxy-revalidate"                     ; Section 14.9.4
        | "max-age" "=" delta-seconds            ; Section 14.9.3
        | "s-maxage" "=" delta-seconds           ; Section 14.9.3
        | cache-extension                        ; Section 14.9.6

   cache-extension = token [ "=" ( token | quoted-string ) ]

.in 3
.fi
When a directive appears without any \%1#field-name parameter, the
directive applies to the entire request or response.  When such a
directive appears with a \%1#field-name parameter, it applies only to
the named field or fields, and not to the rest of the request or
response.  This mechanism supports extensibility; implementations of
future versions of the HTTP protocol might apply these directives to
header fields not defined in HTTP/1.1.

.bp
The \%cache-control directives can be broken down into these general
categories:

.in 6
.ti 3
o  Restrictions on what are cacheable; these may only be imposed by
the origin server.

.ti 3
o  Restrictions on what may be stored by a cache; these may be
imposed by either the origin server or the user agent.

.ti 3
o  Modifications of the basic expiration mechanism; these may be
imposed by either the origin server or the user agent.

.ti 3
o  Controls over cache revalidation and reload; these may only be
imposed by a user agent.

.ti 3
o  Control over transformation of entities.

.ti 3
o  Extensions to the caching system.

.in 3
.in 9
.ti 0
14.9.1.  What is Cacheable
.in 3

By default, a response is cacheable if the requirements of the
request method, request header fields, and the response status
indicate that it is cacheable.  Section\013.4 summarizes these
defaults for cacheability.  The following \%Cache-Control response
directives allow an origin server to override the default
cacheability of a response:

public

.in 6
.ti 6
Indicates that the response MAY be cached by any cache, even if it
would normally be \%non-cacheable or cacheable only within a \%non-
shared cache.  (See also Authorization, Section\014.8, for
additional details.)

.in 3
private

.in 6
.ti 6
Indicates that all or part of the response message is intended for
a single user and MUST NOT be cached by a shared cache.  This
allows an origin server to state that the specified parts of the
response are intended for only one user and are not a valid
response for requests by other users.  A private \%(non-shared)
cache MAY cache the response.

.ti 6
Note: This usage of the word private only controls where the
response may be cached, and cannot ensure the privacy of the
message content.

.bp
.in 3
\%no-cache

.in 6
.ti 6
If the \%no-cache directive does not specify a \%field-name, then a
cache MUST NOT use the response to satisfy a subsequent request
without successful revalidation with the origin server.  This
allows an origin server to prevent caching even by caches that
have been configured to return stale responses to client requests.

.ti 6
If the \%no-cache directive does specify one or more \%field-names,
then a cache MAY use the response to satisfy a subsequent request,
subject to any other restrictions on caching.  However, the
specified \%field-name(s) MUST NOT be sent in the response to a
subsequent request without successful revalidation with the origin
server.  This allows an origin server to prevent the \%re-use of
certain header fields in a response, while still allowing caching
of the rest of the response.

.in 9
.ti 9
Note: Most HTTP/1.0 caches will not recognize or obey this
directive.

.in 6
.in 3
.in 9
.ti 0
14.9.2.  What May be Stored by Caches
.in 3

\%no-store

.in 6
.ti 6
The purpose of the \%no-store directive is to prevent the
inadvertent release or retention of sensitive information (for
example, on backup tapes).  The \%no-store directive applies to the
entire message, and MAY be sent either in a response or in a
request.  If sent in a request, a cache MUST NOT store any part of
either this request or any response to it.  If sent in a response,
a cache MUST NOT store any part of either this response or the
request that elicited it.  This directive applies to both \%non-
shared and shared caches.  "MUST NOT store" in this context means
that the cache MUST NOT intentionally store the information in
\%non-volatile storage, and MUST make a \%best-effort attempt to
remove the information from volatile storage as promptly as
possible after forwarding it.

.ti 6
Even when this directive is associated with a response, users
might explicitly store such a response outside of the caching
system (e.g., with a "Save As" dialog).  History buffers MAY store
such responses as part of their normal operation.

.ti 6
The purpose of this directive is to meet the stated requirements
of certain users and service authors who are concerned about
accidental releases of information via unanticipated accesses to
cache data structures.  While the use of this directive might
improve privacy in some cases, we caution that it is NOT in any
.bp
way a reliable or sufficient mechanism for ensuring privacy.  In
particular, malicious or compromised caches might not recognize or
obey this directive, and communications networks might be
vulnerable to eavesdropping.

.in 3
.in 9
.ti 0
14.9.3.  Modifications of the Basic Expiration Mechanism
.in 3

The expiration time of an entity MAY be specified by the origin
server using the Expires header (see Section\014.21).  Alternatively,
it MAY be specified using the \%max-age directive in a response.  When
the \%max-age \%cache-control directive is present in a cached response,
the response is stale if its current age is greater than the age
value given (in seconds) at the time of a new request for that
resource.  The \%max-age directive on a response implies that the
response is cacheable (i.e., "public") unless some other, more
restrictive cache directive is also present.

If a response includes both an Expires header and a \%max-age
directive, the \%max-age directive overrides the Expires header, even
if the Expires header is more restrictive.  This rule allows an
origin server to provide, for a given response, a longer expiration
time to an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache.  This
might be useful if certain HTTP/1.0 caches improperly calculate ages
or expiration times, perhaps due to desynchronized clocks.

Many HTTP/1.0 cache implementations will treat an Expires value that
is less than or equal to the response Date value as being equivalent
to the \%Cache-Control response directive \%"no-cache".  If an HTTP/1.1
cache receives such a response, and the response does not include a
\%Cache-Control header field, it SHOULD consider the response to be
\%non-cacheable in order to retain compatibility with HTTP/1.0 servers.

.in 6
.ti 6
Note: An origin server might wish to use a relatively new HTTP
cache control feature, such as the "private" directive, on a
network including older caches that do not understand that
feature.  The origin server will need to combine the new feature
with an Expires field whose value is less than or equal to the
Date value.  This will prevent older caches from improperly
caching the response.

.in 3
\%s-maxage

.in 6
.ti 6
If a response includes an \%s-maxage directive, then for a shared
cache (but not for a private cache), the maximum age specified by
this directive overrides the maximum age specified by either the
\%max-age directive or the Expires header.  The \%s-maxage directive
also implies the semantics of the \%proxy-revalidate directive (see
Section\014.9.4), i.e., that the shared cache must not use the
.bp
entry after it becomes stale to respond to a subsequent request
without first revalidating it with the origin server.  The
\%s-maxage directive is always ignored by a private cache.

.in 3
Note that most older caches, not compliant with this specification,
do not implement any \%cache-control directives.  An origin server
wishing to use a \%cache-control directive that restricts, but does not
prevent, caching by an \%HTTP/1.1-compliant cache MAY exploit the
requirement that the \%max-age directive overrides the Expires header,
and the fact that \%pre-HTTP/1.1-compliant caches do not observe the
\%max-age directive.

Other directives allow a user agent to modify the basic expiration
mechanism.  These directives MAY be specified on a request:

\%max-age

.in 6
.ti 6
Indicates that the client is willing to accept a response whose
age is no greater than the specified time in seconds.  Unless \%max-
stale directive is also included, the client is not willing to
accept a stale response.

.in 3
\%min-fresh

.in 6
.ti 6
Indicates that the client is willing to accept a response whose
freshness lifetime is no less than its current age plus the
specified time in seconds.  That is, the client wants a response
that will still be fresh for at least the specified number of
seconds.

.in 3
\%max-stale

.in 6
.ti 6
Indicates that the client is willing to accept a response that has
exceeded its expiration time.  If \%max-stale is assigned a value,
then the client is willing to accept a response that has exceeded
its expiration time by no more than the specified number of
seconds.  If no value is assigned to \%max-stale, then the client is
willing to accept a stale response of any age.

.in 3
If a cache returns a stale response, either because of a \%max-stale
directive on a request, or because the cache is configured to
override the expiration time of a response, the cache MUST attach a
Warning header to the stale response, using Warning 110 (Response is
stale).

A cache MAY be configured to return stale responses without
validation, but only if this does not conflict with any \%"MUST"-level
requirements concerning cache validation (e.g., a \%"must-revalidate"
.bp
\%cache-control directive).

If both the new request and the cached entry include \%"max-age"
directives, then the lesser of the two values is used for determining
the freshness of the cached entry for that request.

.in 9
.ti 0
14.9.4.  Cache Revalidation and Reload Controls
.in 3

Sometimes a user agent might want or need to insist that a cache
revalidate its cache entry with the origin server (and not just with
the next cache along the path to the origin server), or to reload its
cache entry from the origin server.  \%End-to-end revalidation might be
necessary if either the cache or the origin server has overestimated
the expiration time of the cached response.  \%End-to-end reload may be
necessary if the cache entry has become corrupted for some reason.

\%End-to-end revalidation may be requested either when the client does
not have its own local cached copy, in which case we call it
"unspecified \%end-to-end revalidation", or when the client does have a
local cached copy, in which case we call it "specific \%end-to-end
revalidation."

The client can specify these three kinds of action using \%Cache-
Control request directives:

\%End-to-end reload

.in 6
.ti 6
The request includes a \%"no-cache" \%cache-control directive or, for
compatibility with HTTP/1.0 clients, "Pragma: \%no-cache".  Field
names MUST NOT be included with the \%no-cache directive in a
request.  The server MUST NOT use a cached copy when responding to
such a request.

.in 3
Specific \%end-to-end revalidation

.in 6
.ti 6
The request includes a \%"max-age=0" \%cache-control directive, which
forces each cache along the path to the origin server to
revalidate its own entry, if any, with the next cache or server.
The initial request includes a \%cache-validating conditional with
the client\'s current validator.

.in 3
Unspecified \%end-to-end revalidation

.in 6
.ti 6
The request includes \%"max-age=0" \%cache-control directive, which
forces each cache along the path to the origin server to
revalidate its own entry, if any, with the next cache or server.
The initial request does not include a \%cache-validating
conditional; the first cache along the path (if any) that holds a
.bp
cache entry for this resource includes a \%cache-validating
conditional with its current validator.

.in 3
\%max-age

.in 6
.ti 6
When an intermediate cache is forced, by means of a \%max-age=0
directive, to revalidate its own cache entry, and the client has
supplied its own validator in the request, the supplied validator
might differ from the validator currently stored with the cache
entry.  In this case, the cache MAY use either validator in making
its own request without affecting semantic transparency.

.ti 6
However, the choice of validator might affect performance.  The
best approach is for the intermediate cache to use its own
validator when making its request.  If the server replies with 304
(Not Modified), then the cache can return its now validated copy
to the client with a 200 (OK) response.  If the server replies
with a new entity and cache validator, however, the intermediate
cache can compare the returned validator with the one provided in
the client\'s request, using the strong comparison function.  If
the client\'s validator is equal to the origin server\'s, then the
intermediate cache simply returns 304 (Not Modified).  Otherwise,
it returns the new entity with a 200 (OK) response.

.ti 6
If a request includes the \%no-cache directive, it SHOULD NOT
include \%min-fresh, \%max-stale, or \%max-age.

.in 3
\%only-if-cached

.in 6
.ti 6
In some cases, such as times of extremely poor network
connectivity, a client may want a cache to return only those
responses that it currently has stored, and not to reload or
revalidate with the origin server.  To do this, the client may
include the \%only-if-cached directive in a request.  If it receives
this directive, a cache SHOULD either respond using a cached entry
that is consistent with the other constraints of the request, or
respond with a 504 (Gateway Timeout) status.  However, if a group
of caches is being operated as a unified system with good internal
connectivity, such a request MAY be forwarded within that group of
caches.

.in 3
\%must-revalidate

.in 6
.ti 6
Because a cache MAY be configured to ignore a server\'s specified
expiration time, and because a client request MAY include a \%max-
stale directive (which has a similar effect), the protocol also
includes a mechanism for the origin server to require revalidation
of a cache entry on any subsequent use.  When the \%must-revalidate
.bp
directive is present in a response received by a cache, that cache
MUST NOT use the entry after it becomes stale to respond to a
subsequent request without first revalidating it with the origin
server.  (I.e., the cache MUST do an \%end-to-end revalidation every
time, if, based solely on the origin server\'s Expires or \%max-age
value, the cached response is stale.)

.ti 6
The \%must-revalidate directive is necessary to support reliable
operation for certain protocol features.  In all circumstances an
HTTP/1.1 cache MUST obey the \%must-revalidate directive; in
particular, if the cache cannot reach the origin server for any
reason, it MUST generate a 504 (Gateway Timeout) response.

.ti 6
Servers SHOULD send the \%must-revalidate directive if and only if
failure to revalidate a request on the entity could result in
incorrect operation, such as a silently unexecuted financial
transaction.  Recipients MUST NOT take any automated action that
violates this directive, and MUST NOT automatically provide an
unvalidated copy of the entity if revalidation fails.

.ti 6
Although this is not recommended, user agents operating under
severe connectivity constraints MAY violate this directive but, if
so, MUST explicitly warn the user that an unvalidated response has
been provided.  The warning MUST be provided on each unvalidated
access, and SHOULD require explicit user confirmation.

.in 3
\%proxy-revalidate

.in 6
.ti 6
The \%proxy-revalidate directive has the same meaning as the \%must-
revalidate directive, except that it does not apply to \%non-shared
user agent caches.  It can be used on a response to an
authenticated request to permit the user\'s cache to store and
later return the response without needing to revalidate it (since
it has already been authenticated once by that user), while still
requiring proxies that service many users to revalidate each time
(in order to make sure that each user has been authenticated).
Note that such authenticated responses also need the public cache
control directive in order to allow them to be cached at all.

.in 3
.in 9
.ti 0
14.9.5.  \%No-Transform Directive
.in 3

\%no-transform

.in 6
.ti 6
Implementors of intermediate caches (proxies) have found it useful
to convert the media type of certain entity bodies.  A \%non-
transparent proxy might, for example, convert between image
formats in order to save cache space or to reduce the amount of
traffic on a slow link.
.bp
.ti 6
Serious operational problems occur, however, when these
transformations are applied to entity bodies intended for certain
kinds of applications.  For example, applications for medical
imaging, scientific data analysis and those using \%end-to-end
authentication, all depend on receiving an entity body that is bit
for bit identical to the original \%entity-body.

.ti 6
Therefore, if a message includes the \%no-transform directive, an
intermediate cache or proxy MUST NOT change those headers that are
listed in Section\013.5.2 as being subject to the \%no-transform
directive.  This implies that the cache or proxy MUST NOT change
any aspect of the \%entity-body that is specified by these headers,
including the value of the \%entity-body itself.

.in 3
.in 9
.ti 0
14.9.6.  Cache Control Extensions
.in 3

The \%Cache-Control header field can be extended through the use of one
or more \%cache-extension tokens, each with an optional assigned value.
Informational extensions (those which do not require a change in
cache behavior) MAY be added without changing the semantics of other
directives.  Behavioral extensions are designed to work by acting as
modifiers to the existing base of cache directives.  Both the new
directive and the standard directive are supplied, such that
applications which do not understand the new directive will default
to the behavior specified by the standard directive, and those that
understand the new directive will recognize it as modifying the
requirements associated with the standard directive.  In this way,
extensions to the \%cache-control directives can be made without
requiring changes to the base protocol.

This extension mechanism depends on an HTTP cache obeying all of the
\%cache-control directives defined for its native \%HTTP-version, obeying
certain extensions, and ignoring all directives that it does not
understand.

For example, consider a hypothetical new response directive called
community which acts as a modifier to the private directive.  We
define this new directive to mean that, in addition to any \%non-shared
cache, any cache which is shared only by members of the community
named within its value may cache the response.  An origin server
wishing to allow the UCI community to use an otherwise private
response in their shared cache(s) could do so by including
.nf

    Cache-Control: private, community="UCI"

.fi
A cache seeing this header field will act correctly even if the cache
does not understand the community \%cache-extension, since it will also
see and understand the private directive and thus default to the safe
.bp
behavior.

Unrecognized \%cache-directives MUST be ignored; it is assumed that any
\%cache-directive likely to be unrecognized by an HTTP/1.1 cache will
be combined with standard directives (or the response\'s default
cacheability) such that the cache behavior will remain minimally
correct even if the cache does not understand the extension(s).

.in 8
.ti 0
14.10.  Connection
.in 3

The Connection \%general-header field allows the sender to specify
options that are desired for that particular connection and MUST NOT
be communicated by proxies over further connections.

The Connection header has the following grammar:
.nf

    Connection = "Connection" ":" 1#(connection-token)
    connection-token  = token

.fi
HTTP/1.1 proxies MUST parse the Connection header field before a
message is forwarded and, for each \%connection-token in this field,
remove any header field(s) from the message with the same name as the
\%connection-token.  Connection options are signaled by the presence of
a \%connection-token in the Connection header field, not by any
corresponding additional header field(s), since the additional header
field may not be sent if there are no parameters associated with that
connection option.

Message headers listed in the Connection header MUST NOT include \%end-
\%to-end headers, such as \%Cache-Control.

HTTP/1.1 defines the "close" connection option for the sender to
signal that the connection will be closed after completion of the
response.  For example,
.nf

    Connection: close

.fi
in either the request or the response header fields indicates that
the connection SHOULD NOT be considered `persistent\' (Section\08.1)
after the current request/response is complete.

HTTP/1.1 applications that do not support persistent connections MUST
include the "close" connection option in every message.

A system receiving an HTTP/1.0 (or \%lower-version) message that
includes a Connection header MUST, for each \%connection-token in this
field, remove and ignore any header field(s) from the message with
the same name as the \%connection-token.  This protects against
.bp
mistaken forwarding of such header fields by \%pre-HTTP/1.1 proxies.
See App